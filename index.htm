<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vệ Binh Tinh Linh</title>
    <script src="https://unpkg.com/gifler@0.1.0/gifler.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Great+Vibes&family=Roboto:ital,wght@1,300&family=VT323&display=swap" rel="stylesheet">
    <style>
        /* TẤT CẢ CSS TỪ CẢ 2 FILE ĐƯỢC GỘP VÀO ĐÂY */
        body {
            background-color: #0d1a26;
            color: #fff;
            font-family: 'VT323', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* --- CÁC THÀNH PHẦN CHUNG & INTRO STYLES --- */
        #intro-screen { width: 100%; height: 100%; }
        #background-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
        .intro-container { text-align: center; background-color: transparent; position: relative; z-index: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%;}
        .game-title { margin-bottom: 50px; }
        .game-title span { display: block; min-height: 50px; }
        #title-line-1 { font-family: 'Black Ops One', cursive; font-size: 5rem; color: #aef; text-shadow: 3px 3px 10px rgba(174, 239, 255, 0.7); letter-spacing: 2px; }
        #title-line-2 { font-family: 'Roboto', sans-serif; font-size: 2rem; font-weight: 300; font-style: italic; color: #fff; margin-top: -10px; text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); }
        #title-line-3 { font-family: 'Great Vibes', cursive; font-size: 4.5rem; color: #f5b041; text-shadow: 2px 2px 8px rgba(245, 176, 65, 0.6); }
        .intro-menu { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .menu-btn { font-family: 'VT323', monospace; font-size: 24px; padding: 12px 24px; border: 2px solid #fff; background-color: #555; color: #fff; cursor: pointer; box-shadow: 0 5px 0 #333; transition: all 0.1s ease-out; width: 300px; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); }
        .menu-btn.secondary { background-color: #334; font-size: 20px; padding: 10px 20px; box-shadow: 0 4px 0 #112; width: 280px; }
        .menu-btn:active { transform: translateY(5px); box-shadow: none; }
        .menu-btn.secondary:active { transform: translateY(4px); box-shadow: none; }

        /* --- GAME STYLES --- */
        #game-screen { display: none; width: 100%; height: 100%; flex-direction: column; align-items: center; padding-top: 20px; box-sizing: border-box; }
        #game-container { position: relative; border: 2px solid #fff; box-shadow: 0 0 20px #fff; width: 95%; max-width: 800px; aspect-ratio: 4 / 3; overflow: hidden; }
        canvas#game-canvas { display: block; background-color: #111; image-rendering: pixelated; width: 100%; height: 100%; cursor: default; }
        canvas.targeting { cursor: pointer; }
        .ui-panel { position: absolute; background-color: rgba(0, 0, 50, 0.8); border: 2px solid #aef; color: #fff; padding: 10px; box-sizing: border-box; display: none; user-select: none; }
        #info-panel { top: 10px; left: 50%; transform: translateX(-50%); width: 80%; max-width: 450px; padding: 8px 15px; font-size: 18px; text-align: center; z-index: 15; }
        #message-box { bottom: 0; left: 0; width: 100%; height: 120px; font-size: 18px; line-height: 1.4; word-wrap: break-word; white-space: pre-wrap; z-index: 10; cursor: pointer; }
        #next-indicator { position: absolute; bottom: 10px; right: 20px; display: none; animation: bounce 1s infinite; font-size: 24px; }
        @keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-5px); } }
        #battle-menu, #magic-menu { bottom: 0; right: 0; width: 160px; height: 120px; z-index: 5; overflow-y: auto; }
        .battle-menu-list ul { list-style: none; padding: 0; margin: 0; }
        .battle-menu-list li { padding: 6px; cursor: pointer; font-size: 18px; }
        .battle-menu-list li.selected { background-color: #fff; color: #000; }
        .battle-menu-list li:before { content: '▶ '; opacity: 0; }
        .battle-menu-list li.selected:before { opacity: 1; }
        #player-stats, #enemy-stats { top: 10px; padding: 8px; font-size: 16px; line-height: 1.2; }
        #player-stats { left: 10px; width: 180px; }
        #enemy-stats { right: 10px; width: 220px; font-size: 14px; max-height: 120px; overflow-y: auto; }
        .hp-bar-container { width: 100%; height: 10px; background-color: #555; border: 1px solid #fff; margin-top: 5px; margin-bottom: 8px; }
        .hp-bar { height: 100%; background-color: #0f0; width: 100%; }
        .mp-bar { height: 100%; background-color: #00f; width: 100%; }
        #game-over-screen { top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); justify-content: center; align-items: center; font-size: 40px; text-align: center; }
        #target-selector { position: absolute; display: none; width: 24px; height: 24px; color: red; font-size: 32px; animation: bounce 1s infinite; z-index: 20; text-shadow: 0 0 5px #fff; }
        .game-menu-buttons { position: fixed; top: 25px; right: 25px; z-index: 101; display: flex; gap: 10px; }
        .game-menu-buttons button { padding: 8px 12px; background-color: #aef; color: #000; border: 2px solid #000; cursor: pointer; font-family: 'VT323', monospace; font-size: 24px; line-height: 1; }
        #d-pad-container { position: fixed; bottom: 20px; left: 20px; z-index: 100; display: grid; grid-template-areas: ". up ." "left . right" ". down ."; gap: 8px; user-select: none; }
        .d-pad-btn { width: 60px; height: 60px; background-color: rgba(174, 239, 255, 0.5); border: 2px solid #aef; color: #fff; font-size: 28px; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        .d-pad-btn:active { background-color: rgba(174, 239, 255, 0.8); }
        #d-pad-up { grid-area: up; } #d-pad-down { grid-area: down; } #d-pad-left { grid-area: left; } #d-pad-right { grid-area: right; }

        /* --- MODAL STYLES (DÙNG CHUNG) --- */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; z-index: 1000; font-family: 'VT323', monospace; }
        .modal-content { background-color: #000032; padding: 30px; border: 2px solid #aef; border-radius: 10px; width: 90%; max-width: 700px; display: flex; flex-direction: column; max-height: 85vh; }
        .modal-content h2 { margin-top: 0; font-size: 28px; flex-shrink: 0; }
        .modal-body { display: flex; gap: 20px; min-height: 300px; flex: 1; overflow-y: auto; min-height: 0; }
        .modal-buttons { text-align: right; margin-top: 20px; flex-shrink: 0; }
        .input-group { margin-bottom: 15px; }
        .input-group label { display: block; margin-bottom: 5px; font-size: 18px; }
        .input-group input[type="text"], .input-group input[type="number"], .input-group input[type="file"], .input-group input[type="color"] { width: 100%; padding: 8px; background-color: #112; border: 1px solid #aef; color: #fff; font-family: 'VT323', monospace; font-size: 16px; box-sizing: border-box; }
        .input-group input[type="color"] { padding: 4px; height: 40px; }
        .input-group-divider { text-align: center; margin: 10px 0; font-style: italic; }
        .modal-btn { padding: 8px 16px; background-color: #aef; color: #000; border: none; cursor: pointer; font-family: 'VT323', monospace; font-size: 18px; margin-left: 10px; }
        .modal-btn.primary { background-color: #5f5; }
        .modal-btn.danger { background-color: #f55; }
        .list-panel { width: 35%; border-right: 1px solid #aef; padding-right: 20px; }
        .details-panel { width: 65%; overflow-y: auto; padding: 0 10px;}
        .item-list { list-style: none; padding: 0; margin: 0; max-height: 400px; overflow-y: auto; }
        .item-list li { padding: 8px; cursor: pointer; border-bottom: 1px dashed #556; }
        .item-list li:hover, .item-list li.selected { background-color: #114; }
        .item-list .add-item-btn { color: #5f5; font-weight: bold; }
        .detail-view img { background: #000; border: 1px solid #fff; width: 64px; height: 64px; vertical-align: middle; margin-left: 10px; }
        #settings-modal .settings-menu-grid { display: flex; flex-direction: column; gap: 15px; }
        #settings-modal .settings-menu-grid button { width: 100%; padding: 15px; font-size: 20px; }

        /* --- TAB MENU STYLES --- */
        .tab-nav { display: flex; border-bottom: 2px solid #aef; margin-bottom: 15px; flex-shrink: 0; }
        .tab-btn { padding: 10px 15px; cursor: pointer; background-color: transparent; border: none; color: #fff; font-family: 'VT323', monospace; font-size: 20px; border-bottom: 3px solid transparent; margin-bottom: -2px; }
        .tab-btn:hover { background-color: #114; }
        .tab-btn.active { color: #5f5; border-bottom-color: #5f5; }
        .tab-content { flex: 1; overflow-y: auto; min-height: 0; }
        .tab-pane { display: none; font-size: 20px; line-height: 1.6; padding-right: 10px; }
        .tab-pane.active { display: block; }
        .inventory-list, .magic-list { list-style: none; padding: 0; margin: 0; }
        .inventory-list li, .magic-list li { padding: 8px 0; border-bottom: 1px dashed #556; }

        /* --- NEW STYLES FOR IMAGE MANAGER --- */
        #image-manager-modal .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            padding: 10px;
            border: 1px solid #aef;
            max-height: 400px;
            overflow-y: auto;
        }
        #image-manager-modal .image-grid-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 5px;
            border: 1px solid transparent;
            word-break: break-all;
            text-align: center;
        }
        #image-manager-modal .image-grid-item:hover,
        #image-manager-modal .image-grid-item.selected {
            background-color: #114;
            border-color: #5f5;
        }
        #image-manager-modal .image-grid-item img {
            width: 64px;
            height: 64px;
            object-fit: contain;
            border: 1px solid #333;
            background-color: #000;
            margin-bottom: 5px;
        }
        #image-manager-modal .image-detail-view {
            text-align: center;
        }
        #image-manager-modal .image-detail-view img {
            max-width: 128px;
            max-height: 128px;
            object-fit: contain;
            margin-bottom: 15px;
            border: 2px solid #aef;
            background-color: #000;
        }
    </style>
</head>
<body>

    <div id="intro-screen">
        <div class="intro-container">
            <h1 class="game-title">
                <span id="title-line-1"></span><span id="title-line-2"></span><span id="title-line-3"></span>
            </h1>
            <div class="intro-menu">
                <button id="start-game-btn" class="menu-btn">Bắt Đầu</button>
                <button data-modal="customize-modal" class="menu-btn secondary modal-trigger">Tùy Chỉnh Nhân Vật</button>
                <button data-modal="monster-modal" class="menu-btn secondary modal-trigger">Quản Lý Quái Vật</button>
            </div>
        </div>
        <canvas id="background-canvas"></canvas>
    </div>

    <div id="game-screen">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <div id="info-panel" class="ui-panel"></div>
            <div id="target-selector">▼</div>
            <div id="message-box" class="ui-panel">
                 <span id="message-text"></span>
                 <span id="next-indicator">▶</span>
            </div>
            <div id="battle-menu" class="ui-panel battle-menu-list"><ul>
                <li data-action="attack" data-description="Tấn công vật lý một kẻ địch.">Tấn công</li>
                <li data-action="magic" data-description="Sử dụng phép thuật (cần MP).">Phép thuật</li>
                <li data-action="flee" data-description="Cố gắng bỏ chạy khỏi trận đấu.">Bỏ chạy</li>
            </ul></div>
            <div id="magic-menu" class="ui-panel battle-menu-list"><ul id="magic-menu-list"></ul></div>
            <div id="player-stats" class="ui-panel"></div>
            <div id="enemy-stats" class="ui-panel"></div>
            <div id="game-over-screen" class="ui-panel">TRÒ CHƠI KẾT THÚC</div>
        </div>
        <div id="d-pad-container">
            <button id="d-pad-up" class="d-pad-btn">▲</button>
            <button id="d-pad-left" class="d-pad-btn">◀</button>
            <button id="d-pad-right" class="d-pad-btn">▶</button>
            <button id="d-pad-down" class="d-pad-btn">▼</button>
        </div>
        <div class="game-menu-buttons">
            <button data-modal="stats-modal" class="modal-trigger">Menu</button>
            <button data-modal="settings-modal" class="modal-trigger">⚙️</button>
        </div>
    </div>

    <div id="customize-modal" class="modal">
        <div class="modal-content">
            <h2>Tùy Chỉnh Nhân Vật Chính</h2>
            <div class="modal-body">
                <div>
                    <p>Chọn ảnh cho nhân vật.</p>
                    <div class="input-group">
                        <label for="player-sprite-selection">Chọn ảnh từ thư viện:</label>
                        <select id="player-sprite-selection" style="width: 100%; padding: 8px; background-color: #112; border: 1px solid #aef; color: #fff; font-family: 'VT323', monospace; font-size: 16px; box-sizing: border-box;"></select>
                    </div>
                    <p>Hoặc thêm ảnh mới vào Thư Viện Hình Ảnh.</p>
                </div>
            </div>
            <div class="modal-buttons">
                <button id="reset-player-sprite-btn" class="modal-btn danger">Reset về mặc định</button>
                <button id="save-player-sprite-btn" class="modal-btn primary">Lưu</button>
                <button class="modal-btn close-modal-btn">Đóng</button>
            </div>
        </div>
    </div>
    <div id="monster-modal" class="modal">
        <div class="modal-content">
            <h2>Quản Lý Quái Vật</h2>
            <div class="modal-body"><div class="list-panel"><ul id="monster-list" class="item-list"></ul></div><div id="monster-details-panel" class="details-panel"></div></div>
            <div class="modal-buttons"><button class="modal-btn close-modal-btn">Đóng</button></div>
        </div>
    </div>
    <div id="spell-modal" class="modal">
         <div class="modal-content">
            <h2>Quản Lý Phép Thuật</h2>
            <div class="modal-body"><div class="list-panel"><ul id="spell-list" class="item-list"></ul></div><div id="spell-details-panel" class="details-panel"></div></div>
            <div class="modal-buttons"><button class="modal-btn close-modal-btn">Đóng</button></div>
        </div>
    </div>
    <div id="image-manager-modal" class="modal">
        <div class="modal-content">
            <h2>Quản Lý Hình Ảnh</h2>
            <div class="modal-body">
                <div class="list-panel">
                    <ul id="image-list" class="item-list">
                        <li class="add-item-btn" data-image-id="add-new-image">[+] Thêm Hình Ảnh Mới</li>
                    </ul>
                </div>
                <div id="image-details-panel" class="details-panel">
                    </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn close-modal-btn">Đóng</button>
            </div>
        </div>
    </div>
    <div id="settings-modal" class="modal">
    <div class="modal-content">
        <h2>Cài Đặt & Quản Lý</h2>
        <div class="modal-body">
            <div class="settings-menu-grid">
                <button data-modal="customize-modal" class="modal-btn modal-trigger">Tùy Chỉnh Nhân Vật</button>
                <button data-modal="monster-modal" class="modal-btn modal-trigger">Quản Lý Quái Vật</button>
                <button data-modal="spell-modal" class="modal-btn modal-trigger">Quản Lý Phép Thuật</button>
                <button data-modal="image-manager-modal" class="modal-btn modal-trigger">Quản Lý Hình Ảnh</button>
                <button id="export-game-data-btn" class="modal-btn">Xuất Dữ Liệu</button>
                <button id="import-game-data-btn" class="modal-btn">Nhập Dữ Liệu</button>
                <button id="modal-reset-game-btn" class="modal-btn danger">Reset Toàn Bộ Game</button>
            </div>
            <input type="file" id="import-data-file-input" accept=".csv" style="display: none;">
            </div>
        <div class="modal-buttons"><button class="modal-btn close-modal-btn">Đóng</button></div>
    </div>
</div>
    <div id="stats-modal" class="modal">
        <div class="modal-content">
            <h2>Menu</h2>
            <div class="tab-nav">
                <button class="tab-btn active" data-tab="tab-char-info">Nhân Vật</button>
                <button class="tab-btn" data-tab="tab-magic">Phép Thuật</button>
                <button class="tab-btn" data-tab="tab-inventory">Túi Đồ</button>
            </div>
            <div class="tab-content">
                <div id="tab-char-info" class="tab-pane active"></div>
                <div id="tab-magic" class="tab-pane"></div>
                <div id="tab-inventory" class="tab-pane"></div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn close-modal-btn">Đóng</button>
            </div>
        </div>
    </div>

    <script>
 document.addEventListener('DOMContentLoaded', () => {

        // ===================================
        // KHAI BÁO BIẾN VÀ ĐIỀU KHIỂN CHUNG
        // ===================================
        const introScreen = document.getElementById('intro-screen');
        const gameScreen = document.getElementById('game-screen');
        const startGameBtn = document.getElementById('start-game-btn');
        const allModals = document.querySelectorAll('.modal');
        const modalTriggers = document.querySelectorAll('.modal-trigger');
        const closeModalBtns = document.querySelectorAll('.close-modal-btn');
        let playerUnit; // Biến toàn cục cho đơn vị người chơi trong trận đấu

        // ===================================
        // LOGIC CHUYỂN ĐỔI MÀN HÌNH
        // ===================================
        startGameBtn.addEventListener('click', () => {
            introScreen.style.display = 'none';
            gameScreen.style.display = 'flex';
			// ... (existing code for managers and setupTabs)

        // ===================================
        // NEW: EXPORT/IMPORT DATA LOGIC
        // ===================================

        // Helper function to escape CSV values
        function escapeCsv(value) {
            if (value === null || value === undefined) return '';
            let stringValue = String(value);
            // If the value contains a comma, double quote, or newline, enclose it in double quotes
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                // Escape double quotes by doubling them
                stringValue = stringValue.replace(/"/g, '""');
                return `"${stringValue}"`;
            }
            return stringValue;
        }

        // Helper function to unescape CSV values (basic for now)
        function unescapeCsv(value) {
            if (value.startsWith('"') && value.endsWith('"')) {
                return value.substring(1, value.length - 1).replace(/""/g, '"');
            }
            return value;
        }

        document.getElementById('export-game-data-btn').addEventListener('click', () => {
            let csvContent = '';

            // 1. Player Data
            csvContent += 'PLAYER_DATA\n';
            const playerHeader = ['level', 'atk', 'maxHp', 'maxMp', 'battlesWon', 'battlesToNextLevel', 'custom_sprite_player_id', 'custom_sprite_player_config_isSpriteSheet', 'custom_sprite_player_config_frameWidth', 'custom_sprite_player_config_frameHeight', 'custom_sprite_player_config_framesPerRow', 'custom_sprite_player_config_animationRow', 'custom_sprite_player_config_animationSpeed', 'custom_sprite_player_config_totalRows'];
            csvContent += playerHeader.map(escapeCsv).join(',') + '\n';
            const playerStats = playerDataManager.stats;
            const playerSpriteId = localStorage.getItem('custom_sprite_player_id') || 'player_default';
            const playerConfig = localStorage.getItem('custom_sprite_player_config') ? JSON.parse(localStorage.getItem('custom_sprite_player_config')) : {};

            const playerRow = [
                playerStats.level, playerStats.atk, playerStats.maxHp, playerStats.maxMp, playerStats.battlesWon, playerStats.battlesToNextLevel,
                playerSpriteId,
                playerConfig.isSpriteSheet || false,
                playerConfig.frameWidth || 16,
                playerConfig.frameHeight || 16,
                playerConfig.framesPerRow || 1,
                playerConfig.animationRow || 0,
                playerConfig.animationSpeed || 100,
                playerConfig.totalRows || 1
            ];
            csvContent += playerRow.map(escapeCsv).join(',') + '\n\n';

            // 2. Monster Data
            csvContent += 'MONSTER_DATA\n';
            const monsterHeader = ['id', 'name', 'hp', 'atk', 'spriteId', 'specialSkill_name', 'specialSkill_damage', 'specialSkill_chance', 'dropItem_name', 'dropItem_dropRate', 'dropItem_spriteId'];
            csvContent += monsterHeader.map(escapeCsv).join(',') + '\n';
            monsterManager.monsters.forEach(m => {
                const row = [
                    m.id, m.name, m.hp, m.atk, m.spriteId,
                    m.specialSkill.name, m.specialSkill.damage, m.specialSkill.chance,
                    m.dropItem ? m.dropItem.name : '', m.dropItem ? m.dropItem.dropRate : '', m.dropItem ? m.dropItem.spriteId : ''
                ];
                csvContent += row.map(escapeCsv).join(',') + '\n';
            });
            csvContent += '\n';

            // 3. Spell Data
            csvContent += 'SPELL_DATA\n';
            const spellHeader = ['id', 'name', 'mpCost', 'damage', 'effectColor', 'flashes', 'spriteId', 'spriteFlashes'];
            csvContent += spellHeader.map(escapeCsv).join(',') + '\n';
            spellManager.spells.forEach(s => {
                const row = [
                    s.id, s.name, s.mpCost, s.damage, s.effectColor, s.flashes, s.spriteId, s.spriteFlashes
                ];
                csvContent += row.map(escapeCsv).join(',') + '\n';
            });
            csvContent += '\n';

            // 4. Image Data
            csvContent += 'IMAGE_DATA\n';
            const imageHeader = ['id', 'name', 'url', 'isSpriteSheet', 'frameWidth', 'frameHeight', 'framesPerRow', 'animationRow', 'animationSpeed', 'totalRows'];
            csvContent += imageHeader.map(escapeCsv).join(',') + '\n';
            imageManager.images.forEach(img => {
                const row = [
                    img.id, img.name, img.url, img.isSpriteSheet, img.frameWidth, img.frameHeight, img.framesPerRow, img.animationRow, img.animationSpeed, img.totalRows
                ];
                csvContent += row.map(escapeCsv).join(',') + '\n';
            });
            csvContent += '\n';

            // 5. Inventory Data
            csvContent += 'INVENTORY_DATA\n';
            const inventoryHeader = ['itemName', 'quantity'];
            csvContent += inventoryHeader.map(escapeCsv).join(',') + '\n';
            for (const itemName in inventoryManager.items) {
                const row = [itemName, inventoryManager.items[itemName]];
                csvContent += row.map(escapeCsv).join(',') + '\n';
            }
            csvContent += '\n';

            const BOM = '\uFEFF'; // Byte Order Mark for UTF-8
            const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'game_data.csv';
            link.click();
            URL.revokeObjectURL(link.href);
            alert('Dữ liệu game đã được xuất thành công!');
        });

        document.getElementById('import-game-data-btn').addEventListener('click', () => {
            document.getElementById('import-data-file-input').click();
        });

        document.getElementById('import-data-file-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const csvContent = e.target.result;
                try {
                    const sections = csvContent.split(/\n\s*\n/).filter(s => s.trim() !== ''); // Split by double newline or more whitespace

                    let currentSection = '';
                    const parsedData = {
                        playerData: {},
                        monsters: [],
                        spells: [],
                        images: [],
                        inventory: {}
                    };

                    sections.forEach(section => {
                        const lines = section.trim().split('\n');
                        const headerLine = lines[0];

                        if (headerLine.startsWith('PLAYER_DATA')) {
                            currentSection = 'PLAYER_DATA';
                        } else if (headerLine.startsWith('MONSTER_DATA')) {
                            currentSection = 'MONSTER_DATA';
                        } else if (headerLine.startsWith('SPELL_DATA')) {
                            currentSection = 'SPELL_DATA';
                        } else if (headerLine.startsWith('IMAGE_DATA')) {
                            currentSection = 'IMAGE_DATA';
                        } else if (headerLine.startsWith('INVENTORY_DATA')) {
                            currentSection = 'INVENTORY_DATA';
                        } else {
                            // Process actual data lines
                            if (lines.length < 2) return; // Skip empty sections

                            const header = lines[0].split(',').map(unescapeCsv);
                            for (let i = 1; i < lines.length; i++) {
                                const values = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(unescapeCsv); // Split by comma outside quotes
                                if (values.length !== header.length) {
                                     console.warn(`Skipping malformed row in ${currentSection}: "${lines[i]}"`);
                                     continue;
                                }

                                const rowData = {};
                                header.forEach((key, index) => {
                                    rowData[key] = values[index];
                                });

                                if (currentSection === 'PLAYER_DATA') {
                                    parsedData.playerData = {
                                        level: parseInt(rowData.level),
                                        atk: parseInt(rowData.atk),
                                        maxHp: parseInt(rowData.maxHp),
                                        maxMp: parseInt(rowData.maxMp),
                                        battlesWon: parseInt(rowData.battlesWon),
                                        battlesToNextLevel: parseInt(rowData.battlesToNextLevel),
                                        custom_sprite_player_id: rowData.custom_sprite_player_id,
                                        custom_sprite_player_config: {
                                            isSpriteSheet: rowData.custom_sprite_player_config_isSpriteSheet === 'true',
                                            frameWidth: parseInt(rowData.custom_sprite_player_config_frameWidth),
                                            frameHeight: parseInt(rowData.custom_sprite_player_config_frameHeight),
                                            framesPerRow: parseInt(rowData.custom_sprite_player_config_framesPerRow),
                                            animationRow: parseInt(rowData.custom_sprite_player_config_animationRow),
                                            animationSpeed: parseInt(rowData.custom_sprite_player_config_animationSpeed),
                                            totalRows: parseInt(rowData.custom_sprite_player_config_totalRows)
                                        }
                                    };
                                } else if (currentSection === 'MONSTER_DATA') {
                                    parsedData.monsters.push({
                                        id: rowData.id,
                                        name: rowData.name,
                                        hp: parseInt(rowData.hp),
                                        atk: parseInt(rowData.atk),
                                        spriteId: rowData.spriteId,
                                        specialSkill: {
                                            name: rowData.specialSkill_name,
                                            damage: parseInt(rowData.specialSkill_damage),
                                            chance: parseFloat(rowData.specialSkill_chance)
                                        },
                                        dropItem: {
                                            name: rowData.dropItem_name,
                                            dropRate: parseFloat(rowData.dropItem_dropRate),
                                            spriteId: rowData.dropItem_spriteId || null
                                        }
                                    });
                                } else if (currentSection === 'SPELL_DATA') {
                                    parsedData.spells.push({
                                        id: rowData.id,
                                        name: rowData.name,
                                        mpCost: parseInt(rowData.mpCost),
                                        damage: parseInt(rowData.damage),
                                        effectColor: rowData.effectColor,
                                        flashes: parseInt(rowData.flashes),
                                        spriteId: rowData.spriteId || null,
                                        spriteFlashes: parseInt(rowData.spriteFlashes)
                                    });
                                } else if (currentSection === 'IMAGE_DATA') {
                                    parsedData.images.push({
                                        id: rowData.id,
                                        name: rowData.name,
                                        url: rowData.url,
                                        isSpriteSheet: rowData.isSpriteSheet === 'true',
                                        frameWidth: parseInt(rowData.frameWidth),
                                        frameHeight: parseInt(rowData.frameHeight),
                                        framesPerRow: parseInt(rowData.framesPerRow),
                                        animationRow: parseInt(rowData.animationRow),
                                        animationSpeed: parseInt(rowData.animationSpeed),
                                        totalRows: parseInt(rowData.totalRows)
                                    });
                                } else if (currentSection === 'INVENTORY_DATA') {
                                    parsedData.inventory[rowData.itemName] = parseInt(rowData.quantity);
                                }
                            }
                        }
                    });

                    // Clear existing data and load new data
                    localStorage.removeItem('jrpg_playerData');
                    localStorage.removeItem('jrpg_monsters');
                    localStorage.removeItem('jrpg_spells');
                    localStorage.removeItem('jrpg_images');
                    localStorage.removeItem('jrpg_inventory');
                    localStorage.removeItem('custom_sprite_player_id');
                    localStorage.removeItem('custom_sprite_player_config');

                    // Apply imported data
                    if (parsedData.playerData && Object.keys(parsedData.playerData).length > 0) {
                        localStorage.setItem('jrpg_playerData', JSON.stringify(parsedData.playerData));
                        if (parsedData.playerData.custom_sprite_player_id) {
                            localStorage.setItem('custom_sprite_player_id', parsedData.playerData.custom_sprite_player_id);
                        }
                        if (parsedData.playerData.custom_sprite_player_config) {
                             localStorage.setItem('custom_sprite_player_config', JSON.stringify(parsedData.playerData.custom_sprite_player_config));
                        }
                    }

                    if (parsedData.monsters.length > 0) {
                        localStorage.setItem('jrpg_monsters', JSON.stringify(parsedData.monsters));
                    } else { // If imported data is empty, revert to default monsters
                        localStorage.setItem('jrpg_monsters', JSON.stringify(monsterManager.defaultMonsters));
                    }

                    if (parsedData.spells.length > 0) {
                        localStorage.setItem('jrpg_spells', JSON.stringify(parsedData.spells));
                    } else { // If imported data is empty, revert to default spells
                        localStorage.setItem('jrpg_spells', JSON.stringify(spellManager.defaultSpells));
                    }

                    if (parsedData.images.length > 0) {
                        localStorage.setItem('jrpg_images', JSON.stringify(parsedData.images));
                    } else { // If imported data is empty, revert to default images
                        localStorage.setItem('jrpg_images', JSON.stringify(imageManager.defaultImages));
                    }

                    if (Object.keys(parsedData.inventory).length > 0) {
                        localStorage.setItem('jrpg_inventory', JSON.stringify(parsedData.inventory));
                    } else {
                        localStorage.setItem('jrpg_inventory', JSON.stringify({})); // Ensure it's an empty object if no items
                    }

                    alert('Dữ liệu game đã được nhập thành công! Vui lòng tải lại trang để áp dụng thay đổi.');
                    location.reload();

                } catch (error) {
                    console.error('Lỗi khi đọc file CSV:', error);
                    alert('Lỗi khi nhập dữ liệu. Vui lòng kiểm tra định dạng file CSV.');
                }
            };
            reader.readAsText(file);
        });

        // ... (rest of your initializeMainGame function and other scripts)
            initializeMainGame();
        });

        // ===================================
        // LOGIC MÀN HÌNH INTRO
        // ===================================
        class RippleEffect {
            constructor(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.width = window.innerWidth; this.height = window.innerHeight; this.canvas.width = this.width; this.canvas.height = this.height; this.cols = Math.floor(this.width / 8); this.rows = Math.floor(this.height / 8); this.current = new Uint8ClampedArray(this.cols * this.rows); this.previous = new Uint8ClampedArray(this.cols * this.rows); this.damping = 0.95; this.gradientCanvas = document.createElement('canvas'); this.gradientCtx = this.gradientCanvas.getContext('2d'); this.gradientCanvas.width = this.width; this.gradientCanvas.height = this.height; this.imageData = this.ctx.createImageData(this.width, this.height); this.mouse = { x: this.width / 2, y: this.height / 2 }; this.time = 0; window.addEventListener('mousemove', this.onMouseMove.bind(this)); window.addEventListener('resize', this.onResize.bind(this)); this.animate(); }
            createGradient() { const hue1 = this.time * 50; const hue2 = hue1 + 80; const hue3 = hue1 + 160; const color1 = `hsl(${hue1 % 360}, 70%, 50%)`; const color2 = `hsl(${hue2 % 360}, 70%, 60%)`; const color3 = `hsl(${hue3 % 360}, 70%, 50%)`; const gradient = this.gradientCtx.createLinearGradient(0, 0, this.width, this.height); gradient.addColorStop(0, color1); gradient.addColorStop(0.5, color2); gradient.addColorStop(1, color3); this.gradientCtx.fillStyle = gradient; this.gradientCtx.fillRect(0, 0, this.width, this.height); }
            onMouseMove(e) { this.mouse.x = e.clientX; this.mouse.y = e.clientY; this.disturb(Math.floor(this.mouse.x / (this.width / this.cols)), Math.floor(this.mouse.y / (this.height / this.rows)), 255); }
            onResize() { this.width = window.innerWidth; this.height = window.innerHeight; this.canvas.width = this.width; this.canvas.height = this.height; this.cols = Math.floor(this.width / 8); this.rows = Math.floor(this.height / 8); this.current = new Uint8ClampedArray(this.cols * this.rows); this.previous = new Uint8ClampedArray(this.cols * this.rows); this.gradientCanvas.width = this.width; this.gradientCanvas.height = this.height; this.imageData = this.ctx.createImageData(this.width, this.height); }
            disturb(x, y, strength) { if (x > 1 && x < this.cols - 1 && y > 1 && y < this.rows - 1) { this.previous[y * this.cols + x] = strength; } }
            update() { for (let y = 1; y < this.rows - 1; y++) { for (let x = 1; x < this.cols - 1; x++) { const i = y * this.cols + x; const pressure = (this.previous[i - 1] + this.previous[i + 1] + this.previous[i - this.cols] + this.previous[i + this.cols]) / 4 - this.current[i]; this.current[i] = pressure * this.damping; } } [this.previous, this.current] = [this.current, this.previous]; }
            render() { const data = this.imageData.data; const pixels = this.gradientPixels; for (let y = 1; y < this.rows - 1; y++) { for (let x = 1; x < this.cols - 1; x++) { const i = y * this.cols + x; const xOffset = this.previous[i - 1] - this.previous[i + 1]; const yOffset = this.previous[i - this.cols] - this.previous[i + this.cols]; for (let py = 0; py < 8; py++) { for (let px = 0; px < 8; px++) { const screenX = x * 8 + px; const screenY = y * 8 + py; const distortedX = Math.max(0, Math.min(this.width - 1, screenX + xOffset)); const distortedY = Math.max(0, Math.min(this.height - 1, screenY + yOffset)); const pixelIndex = (screenY * this.width + screenX) * 4; const distortedIndex = (Math.floor(distortedY) * this.width + Math.floor(distortedX)) * 4; data[pixelIndex] = pixels[distortedIndex]; data[pixelIndex + 1] = pixels[distortedIndex + 1]; data[pixelIndex + 2] = pixels[distortedIndex + 2]; data[pixelIndex + 3] = 255; } } } } this.ctx.putImageData(this.imageData, 0, 0); }
            animate() { if(introScreen.style.display === 'none') return; this.time += 0.01; this.createGradient(); this.gradientPixels = this.gradientCtx.getImageData(0, 0, this.width, this.height).data; this.update(); this.render(); requestAnimationFrame(this.animate.bind(this)); }
        }
        new RippleEffect(document.getElementById('background-canvas'));

        const typeWriter = (element, text, delay = 100) => { return new Promise(resolve => { let i = 0; element.innerHTML = ""; const timer = setInterval(() => { if (i < text.length) { element.innerHTML += text.charAt(i); i++; } else { clearInterval(timer); resolve(); } }, delay); }); };
        async function animateTitles() { await typeWriter(document.getElementById('title-line-1'), "Vệ Binh Tinh Linh"); await typeWriter(document.getElementById('title-line-2'), "Chương 1"); await typeWriter(document.getElementById('title-line-3'), "Giai điệu Hồi Sinh", 120); }
        animateTitles();

        // ===================================
        // LOGIC CHUNG (MODALS, DATA MANAGERS)
        // ===================================
        const ui = { messageBox: document.getElementById('message-box'), messageText: document.getElementById('message-text'), battleMenu: document.getElementById('battle-menu'), magicMenu: document.getElementById('magic-menu'), magicMenuList: document.getElementById('magic-menu-list'), playerStatsPanel: document.getElementById('player-stats'), enemyStatsPanel: document.getElementById('enemy-stats'), gameOverScreen: document.getElementById('game-over-screen'), nextIndicator: document.getElementById('next-indicator'), targetSelector: document.getElementById('target-selector'), infoPanel: document.getElementById('info-panel')};

        const playerDataManager = { stats: {}, getInitialStats() { return { level: 1, atk: 15, maxHp: 52, maxMp: 23, battlesWon: 0, battlesToNextLevel: 3, }; }, load() { const savedData = localStorage.getItem('jrpg_playerData'); if (savedData) { this.stats = JSON.parse(savedData); if (this.stats.maxHp === undefined) this.stats.maxHp = this.stats.level * 2 + 50; if (this.stats.maxMp === undefined) this.stats.maxMp = this.stats.level * 3 + 20; } else { this.stats = this.getInitialStats(); } }, save() { localStorage.setItem('jrpg_playerData', JSON.stringify(this.stats)); }, levelUp() { this.stats.level++; this.stats.atk += 5; this.stats.maxHp = this.stats.level * 2 + 50; this.stats.maxMp = this.stats.level * 3 + 20; this.stats.battlesWon = 0; this.stats.battlesToNextLevel = this.stats.level * 3; this.save(); } };
        const monsterManager = { monsters: [], defaultMonsters: [ { id: 'Slime', name: 'Slime', hp: 30, atk: 5, spriteId: 'slime_default', specialSkill: { name: 'Phun Axit', damage: 10, chance: 0.2 }, dropItem: { name: 'Hạt Slime', dropRate: 0.5, spriteId: '' } }, { id: 'Goblin', name: 'Goblin', hp: 50, atk: 8, spriteId: 'goblin_default', specialSkill: { name: 'Ném Đá', damage: 15, chance: 0.3 }, dropItem: { name: 'Đá Nhỏ', dropRate: 0.2, spriteId: '' } } ], load() { const savedMonsters = localStorage.getItem('jrpg_monsters'); this.monsters = savedMonsters ? JSON.parse(savedMonsters) : [...this.defaultMonsters]; this.monsters.forEach(m => { if (!m.id) m.id = m.name; if (!m.specialSkill) m.specialSkill = { name: "Tuyệt Kỹ", damage: m.atk * 2, chance: 0.2 }; if (!m.dropItem) m.dropItem = { name: '', dropRate: 0, spriteId: '' }; if (!m.spriteId) m.spriteId = 'slime_default'; }); }, save() { localStorage.setItem('jrpg_monsters', JSON.stringify(this.monsters)); }, add(monsterData) { if (this.monsters.find(m => m.name === monsterData.name)) { alert('Lỗi: Tên quái vật đã tồn tại.'); return false; } this.monsters.push(monsterData); this.save(); return true; }, update(originalName, newData) { const monsterIndex = this.monsters.findIndex(m => m.name === originalName); if (monsterIndex === -1) return false; if (newData.name !== originalName && this.monsters.some(m => m.name === newData.name)) { alert('Lỗi: Tên quái vật mới đã tồn tại.'); return false; } this.monsters[monsterIndex] = { ...this.monsters[monsterIndex], ...newData, id: newData.name }; this.save(); return true; }, delete(monsterName) { this.monsters = this.monsters.filter(m => m.name !== monsterName); this.save(); } };
        const spellManager = { spells: [], defaultSpells: [ { id: 'ice', name: 'Băng', mpCost: 2, damage: 10, effectColor: '#00ffff', flashes: 3, spriteId: null, spriteFlashes: 0 }, { id: 'fire', name: 'Lửa', mpCost: 3, damage: 15, effectColor: '#ff0000', flashes: 2, spriteId: null, spriteFlashes: 0 } ], load() { const savedSpells = localStorage.getItem('jrpg_spells'); this.spells = savedSpells ? JSON.parse(savedSpells) : [...this.defaultSpells]; this.spells.forEach(s => { if (!s.id) s.id = s.name; }); }, save() { localStorage.setItem('jrpg_spells', JSON.stringify(this.spells)); }, add(spellData) { if (this.spells.find(s => s.name === spellData.name)) { alert('Lỗi: Tên phép thuật đã tồn tại.'); return false; } this.spells.push(spellData); this.save(); return true; }, update(originalId, newData) { const spellIndex = this.spells.findIndex(s => s.id === originalId); if (spellIndex === -1) return false; if (newData.name !== this.spells[spellIndex].name && this.spells.some(s => s.name === newData.name)) { alert('Lỗi: Tên phép thuật mới đã tồn tại.'); return false; } this.spells[spellIndex] = { ...this.spells[spellIndex], ...newData, id: newData.name }; this.save(); return true; }, delete(spellId) { this.spells = this.spells.filter(s => s.id !== spellId); this.save(); } };
        const inventoryManager = { items: {}, load() { const savedInventory = localStorage.getItem('jrpg_inventory'); this.items = savedInventory ? JSON.parse(savedInventory) : {}; }, save() { localStorage.setItem('jrpg_inventory', JSON.stringify(this.items)); }, addItem(itemName, quantity = 1) { if (this.items[itemName]) { this.items[itemName] += quantity; } else { this.items[itemName] = quantity; } this.save(); } };

        // ===================================
        // BẮT ĐẦU THAY ĐỔI TẠI ĐÂY
        // ===================================

        // NEW: Image Manager
        const imageManager = {
            images: [],
            defaultImages: [
                { id: 'player_default', name: 'Nhân vật mặc định', url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAHBJREFUOE9jZKAQMOLR/xedgYGBgVGkGwYMQ4FVDwZOkDKEGgA2QoHVRwZsgJyBCgAbIRR6+v9/moGBAZEMoDYkAsZzQARyBCwAssEzhGoA2YwBmwFkMwbMBoB9YvD/4seA/0Sg/iyAGAMABzYnXD9cwrwAAAAASUVORK5CYII=', isSpriteSheet: false, frameWidth: 16, frameHeight: 16, framesPerRow: 1, animationRow: 0, animationSpeed: 100, totalRows: 1 },
                { id: 'slime_default', name: 'Slime mặc định', url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAGFJREFUOE9jZKAQMOLR/xmgyYAPyT5g+L9hZqieOQxYgNylHkC2AIb/gcy/z0DQD0yA3HWBHED2U/g/MHyB+39hMKMNAkCVHJAAGQc0HwBsgA6TAmQcMHEBADlqP2WULmS4AAAAAElFTkSuQmCC', isSpriteSheet: false, frameWidth: 16, frameHeight: 16, framesPerRow: 1, animationRow: 0, animationSpeed: 100, totalRows: 1 },
                { id: 'goblin_default', name: 'Goblin mặc định', url: 'data:image/png;base64,iVBORw0KGgoAAAANSUEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAIhJREFUOE9jZKAQMOLR/xkYGBgZGFlA/c8AASYnLMD//7+ZgYGBgRAVPDgAUQPkvwHy/39mMGLCBsgBkv+D+P8/w/YGBgBBnANCGgAZKAGM2A/AcA3YAGCBj/BwJjCMgAATAGiLhBAP3fGgDBSm7443EJewAAAABJRU5ErkJggg==', isSpriteSheet: false, frameWidth: 16, frameHeight: 16, framesPerRow: 1, animationRow: 0, animationSpeed: 100, totalRows: 1 },
                { id: 'character_1_sprite_sheet', name: 'Sprite Sheet Character 1', url: 'https://cdn.jsdelivr.net/gh/htun99/game-assets@main/Character%201.png', isSpriteSheet: true, frameWidth: 64, frameHeight: 64, framesPerRow: 14, animationRow: 8, animationSpeed: 100, totalRows: 16 }
            ],
            load() {
                const savedImages = localStorage.getItem('jrpg_images');
                this.images = savedImages ? JSON.parse(savedImages) : [...this.defaultImages];
                // Ensure all loaded images have default animation properties if missing
                this.images.forEach(img => {
                    if (img.isSpriteSheet === undefined) img.isSpriteSheet = false;
                    if (img.frameWidth === undefined) img.frameWidth = 16;
                    if (img.frameHeight === undefined) img.frameHeight = 16;
                    if (img.framesPerRow === undefined) img.framesPerRow = 1;
                    if (img.animationRow === undefined) img.animationRow = 0;
                    if (img.animationSpeed === undefined) img.animationSpeed = 100;
                    if (img.totalRows === undefined) img.totalRows = 1;
                });
            },
            save() {
                localStorage.setItem('jrpg_images', JSON.stringify(this.images));
            },
            add(imageData) {
                if (this.images.find(img => img.id === imageData.id)) {
                    alert('Lỗi: ID hình ảnh đã tồn tại. Vui lòng chọn ID khác.');
                    return false;
                }
                if (this.images.find(img => img.name === imageData.name)) {
                    alert('Lỗi: Tên hình ảnh đã tồn tại. Vui lòng chọn tên khác.');
                    return false;
                }
                this.images.push(imageData);
                this.save();
                return true;
            },
            update(originalId, newData) {
                const index = this.images.findIndex(img => img.id === originalId);
                if (index === -1) return false;
                if (newData.id !== originalId && this.images.some(img => img.id === newData.id)) {
                     alert('Lỗi: ID hình ảnh mới đã tồn tại.');
                     return false;
                }
                if (newData.name !== this.images[index].name && this.images.some(img => img.name === newData.name)) {
                    alert('Lỗi: Tên hình ảnh mới đã tồn tại.');
                    return false;
                }
                this.images[index] = { ...this.images[index], ...newData };
                this.save();
                return true;
            },
            delete(imageId) {
                // Prevent deleting default images or images currently in use
                if (this.defaultImages.some(img => img.id === imageId)) {
                    alert('Không thể xóa hình ảnh mặc định.');
                    return;
                }
                // Check if any monster uses this spriteId
                if (monsterManager.monsters.some(m => m.spriteId === imageId)) {
                    alert('Không thể xóa hình ảnh này vì nó đang được sử dụng bởi một quái vật.');
                    return;
                }
                // Check if any spell uses this spriteId
                if (spellManager.spells.some(s => s.spriteId === imageId)) {
                    alert('Không thể xóa hình ảnh này vì nó đang được sử dụng bởi một phép thuật.');
                    return;
                }
                // Check if player uses this spriteId
                if (localStorage.getItem('custom_sprite_player_id') === imageId) {
                    alert('Không thể xóa hình ảnh này vì nó đang được sử dụng làm hình ảnh nhân vật chính.');
                    return;
                }


                this.images = this.images.filter(img => img.id !== imageId);
                this.save();
            },
            getImageById(id) {
                return this.images.find(img => img.id === id);
            }
        };

        // GLOBAL CONFIG FOR PLAYER SPRITE ANIMATION (if it's a sprite sheet)
        let playerSpriteConfig = {
            isSpriteSheet: false,
            frameWidth: 16,     // Default frame width for general sprites
            frameHeight: 16,    // Default frame height for general sprites
            framesPerRow: 1,    // Number of frames in a row
            animationRow: 0,    // Which row to animate (0-indexed)
            animationSpeed: 100, // Milliseconds per frame
            currentFrame: 0,
            lastFrameTime: 0,
            totalRows: 1         // Total number of rows in the spritesheet
        };

        // Modified handleSpriteInput to directly use imageManager data
        // This function is now simplified as it just gets a URL for internal use
        function getImageUrlFromFileOrUrl(urlInput, fileInput, callback) {
            const url = urlInput.value.trim();
            const file = fileInput.files[0];

            if (url) {
                callback(url);
            } else if (file) {
                const reader = new FileReader();
                reader.onload = () => {
                    callback(reader.result);
                };
                reader.readAsDataURL(file);
            } else {
                callback(null);
            }
        }

        modalTriggers.forEach(btn => btn.addEventListener('click', (e) => { e.stopPropagation(); const modalId = btn.dataset.modal; const modal = document.getElementById(modalId); if(modal) { allModals.forEach(m => m.style.display = 'none'); modal.style.display = 'flex';
            if (modalId === 'customize-modal') customizeModal.init(); // NEW: Initialize customize modal dropdown
            if (modalId === 'monster-modal') monsterModal.renderList();
            if (modalId === 'spell-modal') spellModal.renderList();
            if (modalId === 'image-manager-modal') imageManagerModal.renderList(); // NEW: Render image list
            if (modalId === 'stats-modal') { document.querySelector('#stats-modal .tab-btn[data-tab="tab-char-info"]').click(); }
        }}));
        closeModalBtns.forEach(btn => btn.addEventListener('click', () => { btn.closest('.modal').style.display = 'none'; }));

        // MODIFIED: Customize Player Modal logic
        const customizeModal = {
            playerSpriteSelect: document.getElementById('player-sprite-selection'),
            init() {
                this.populateSpriteSelect();
                const currentPlayerSpriteId = localStorage.getItem('custom_sprite_player_id');
                if (currentPlayerSpriteId) {
                    this.playerSpriteSelect.value = currentPlayerSpriteId;
                }
            },
            populateSpriteSelect() {
                this.playerSpriteSelect.innerHTML = '';
                imageManager.images.forEach(img => {
                    const option = document.createElement('option');
                    option.value = img.id;
                    option.textContent = img.name;
                    this.playerSpriteSelect.appendChild(option);
                });
            }
        };

        document.getElementById('save-player-sprite-btn').addEventListener('click', () => {
            const selectedSpriteId = customizeModal.playerSpriteSelect.value;
            const selectedSprite = imageManager.getImageById(selectedSpriteId);

            if (selectedSprite) {
                localStorage.setItem('custom_sprite_player_id', selectedSprite.id); // Save ID
                localStorage.setItem('custom_sprite_player_config', JSON.stringify({
                    isSpriteSheet: selectedSprite.isSpriteSheet,
                    frameWidth: selectedSprite.frameWidth,
                    frameHeight: selectedSprite.frameHeight,
                    framesPerRow: selectedSprite.framesPerRow,
                    animationRow: selectedSprite.animationRow,
                    animationSpeed: selectedSprite.animationSpeed,
                    totalRows: selectedSprite.totalRows
                }));
                alert('Đã lưu! Tải lại trang để thấy thay đổi.');
            } else {
                alert('Vui lòng chọn một hình ảnh hợp lệ.');
            }
        });

        document.getElementById('reset-player-sprite-btn').addEventListener('click', () => {
            localStorage.removeItem('custom_sprite_player_id');
            localStorage.removeItem('custom_sprite_player_config');
            alert('Đã reset. Tải lại trang để thấy thay đổi.');
            customizeModal.init(); // Re-populate select after reset
        });

        document.getElementById('modal-reset-game-btn').addEventListener('click', () => { if (confirm('Bạn có chắc muốn reset toàn bộ dữ liệu game?')) { localStorage.clear(); alert('Đã reset game! Trang sẽ được tải lại.'); location.reload(); } });

        const monsterModal = {
            listEl: document.getElementById('monster-list'),
            detailsEl: document.getElementById('monster-details-panel'),
            renderList() {
                this.listEl.innerHTML = '';
                const addLi = document.createElement('li');
                addLi.textContent = '[+] Thêm Quái Vật Mới';
                addLi.className = 'add-item-btn';
                addLi.onclick = () => {
                    this.renderAddForm();
                    document.querySelectorAll('#monster-list li').forEach(el => el.classList.remove('selected'));
                    addLi.classList.add('selected');
                };
                this.listEl.appendChild(addLi);
                monsterManager.monsters.forEach(monster => {
                    const li = document.createElement('li');
                    li.textContent = monster.name;
                    li.onclick = () => {
                        this.renderDetails(monster);
                        document.querySelectorAll('#monster-list li').forEach(el => el.classList.remove('selected'));
                        li.classList.add('selected');
                    };
                    this.listEl.appendChild(li);
                });
                this.renderAddForm(); // Default to add form
                addLi.classList.add('selected');
            },
            renderDetails(monster) {
                const sprite = imageManager.getImageById(monster.spriteId);
                let dropInfoHtml = '<p>Không có vật phẩm rơi.</p>';
                if (monster.dropItem && monster.dropItem.name) {
                    const dropSprite = monster.dropItem.spriteId ? imageManager.getImageById(monster.dropItem.spriteId) : null;
                    dropInfoHtml = `
                        <p>Tên Hạt: ${monster.dropItem.name}</p>
                        <p>Tỷ lệ rơi: ${monster.dropItem.dropRate * 100}%</p>
                        ${dropSprite ? `<p>Hình ảnh: <img src="${dropSprite.url}" class="detail-view"></p>` : ''}
                    `;
                }
                this.detailsEl.innerHTML = `
                    <h3>${monster.name}</h3>
                    <div class="detail-view">
                        Hình ảnh: <img src="${sprite ? sprite.url : ''}" alt="${monster.name}"> (${sprite ? sprite.name : 'Không có'})
                    </div>
                    <p>HP Gốc: ${monster.hp}</p>
                    <p>ATK: ${monster.atk}</p>
                    <h4>Tuyệt Kỹ</h4>
                    <p>Tên: ${monster.specialSkill.name}</p>
                    <p>Sát thương: ${monster.specialSkill.damage}</p>
                    <p>Tỷ lệ: ${monster.specialSkill.chance * 100}%</p>
                    <hr>
                    <h4>Vật phẩm rơi</h4>
                    ${dropInfoHtml}
                    <div class="modal-buttons">
                        <button id="edit-monster-btn" class="modal-btn">Chỉnh Sửa</button>
                        <button id="delete-monster-btn" class="modal-btn danger">Xóa</button>
                    </div>
                `;
                document.getElementById('edit-monster-btn').onclick = () => this.renderEditForm(monster);
                document.getElementById('delete-monster-btn').onclick = () => {
                    if (confirm(`Bạn có chắc muốn xóa ${monster.name}?`)) {
                        monsterManager.delete(monster.name);
                        this.renderList();
                    }
                }
            },
            renderAddForm() {
                let spriteOptions = '';
                imageManager.images.forEach(img => {
                    spriteOptions += `<option value="${img.id}">${img.name}</option>`;
                });
                this.detailsEl.innerHTML = `
                    <h3>Thêm Quái Vật Mới</h3>
                    <div class="input-group"><label>Tên:</label><input type="text" id="new-monster-name" required></div>
                    <div class="input-group"><label>HP:</label><input type="number" id="new-monster-hp" value="10" required></div>
                    <div class="input-group"><label>ATK:</label><input type="number" id="new-monster-atk" value="5" required></div>
                    <div class="input-group">
                        <label for="new-monster-sprite-id">Chọn ảnh:</label>
                        <select id="new-monster-sprite-id">${spriteOptions}</select>
                    </div>
                    <hr>
                    <h4>Tuyệt Kỹ</h4>
                    <div class="input-group"><label>Tên:</label><input type="text" id="new-skill-name" value="Cú Đấm Mạnh" required></div>
                    <div class="input-group"><label>Sát thương:</label><input type="number" id="new-skill-damage" value="10" required></div>
                    <div class="input-group"><label>Tỷ lệ (0.0-1.0):</label><input type="number" id="new-skill-chance" value="0.25" step="0.01" min="0" max="1" required></div>
                    <hr>
                    <h4>Vật phẩm rơi (tùy chọn)</h4>
                    <div class="input-group"><label>Tên Hạt:</label><input type="text" id="new-drop-name"></div>
                    <div class="input-group"><label>Tỷ lệ rơi (0.0-1.0):</label><input type="number" id="new-drop-rate" value="0.1" step="0.01" min="0" max="1"></div>
                    <div class="input-group">
                        <label for="new-drop-sprite-id">Chọn ảnh Hạt:</label>
                        <select id="new-drop-sprite-id">
                            <option value="">Không có</option>
                            ${spriteOptions}
                        </select>
                    </div>
                    <div class="modal-buttons"><button id="save-new-monster-btn" class="modal-btn primary">Lưu</button></div>
                `;
                document.getElementById('save-new-monster-btn').onclick = () => {
                    const name = document.getElementById('new-monster-name').value;
                    const hp = parseInt(document.getElementById('new-monster-hp').value);
                    const atk = parseInt(document.getElementById('new-monster-atk').value);
                    const spriteId = document.getElementById('new-monster-sprite-id').value;
                    const skillName = document.getElementById('new-skill-name').value;
                    const skillDamage = parseInt(document.getElementById('new-skill-damage').value);
                    const skillChance = parseFloat(document.getElementById('new-skill-chance').value);
                    const dropName = document.getElementById('new-drop-name').value;
                    const dropRate = parseFloat(document.getElementById('new-drop-rate').value);
                    const dropSpriteId = document.getElementById('new-drop-sprite-id').value;

                    if (!name || !hp || !atk || !spriteId || !skillName || !skillDamage || isNaN(skillChance)) {
                        alert('Vui lòng điền đủ thông tin bắt buộc.');
                        return;
                    }

                    const newMonster = {
                        id: name,
                        name,
                        hp,
                        atk,
                        spriteId: spriteId,
                        specialSkill: { name: skillName, damage: skillDamage, chance: skillChance },
                        dropItem: { name: dropName, dropRate: (dropName && !isNaN(dropRate)) ? dropRate : 0, spriteId: dropSpriteId || null }
                    };
                    if (monsterManager.add(newMonster)) {
                        alert('Đã thêm quái vật!');
                        this.renderList();
                    }
                };
            },
            renderEditForm(monster) {
                let spriteOptions = '';
                imageManager.images.forEach(img => {
                    spriteOptions += `<option value="${img.id}" ${img.id === monster.spriteId ? 'selected' : ''}>${img.name}</option>`;
                });
                const drop = monster.dropItem || {};
                let dropSpriteOptions = '<option value="">Không có</option>';
                imageManager.images.forEach(img => {
                    dropSpriteOptions += `<option value="${img.id}" ${img.id === drop.spriteId ? 'selected' : ''}>${img.name}</option>`;
                });

                this.detailsEl.innerHTML = `
                    <h3>Chỉnh sửa: ${monster.name}</h3>
                    <div class="input-group"><label>Tên:</label><input type="text" id="edit-monster-name" value="${monster.name}" required></div>
                    <div class="input-group"><label>HP:</label><input type="number" id="edit-monster-hp" value="${monster.hp}" required></div>
                    <div class="input-group"><label>ATK:</label><input type="number" id="edit-monster-atk" value="${monster.atk}" required></div>
                    <div class="input-group">
                        <label for="edit-monster-sprite-id">Chọn ảnh:</label>
                        <select id="edit-monster-sprite-id">${spriteOptions}</select>
                    </div>
                    <hr>
                    <h4>Tuyệt Kỹ</h4>
                    <div class="input-group"><label>Tên:</label><input type="text" id="edit-skill-name" value="${monster.specialSkill.name}" required></div>
                    <div class="input-group"><label>Sát thương:</label><input type="number" id="edit-skill-damage" value="${monster.specialSkill.damage}" required></div>
                    <div class="input-group"><label>Tỷ lệ:</label><input type="number" id="edit-skill-chance" value="${monster.specialSkill.chance}" step="0.01" min="0" max="1" required></div>
                    <hr>
                    <h4>Vật phẩm rơi (tùy chọn)</h4>
                    <div class="input-group"><label>Tên Hạt:</label><input type="text" id="edit-drop-name" value="${drop.name || ''}"></div>
                    <div class="input-group"><label>Tỷ lệ rơi (0.0 - 1.0):</label><input type="number" id="edit-drop-rate" value="${drop.dropRate || 0.1}" step="0.01" min="0" max="1"></div>
                    <div class="input-group">
                        <label for="edit-drop-sprite-id">Chọn ảnh Hạt:</label>
                        <select id="edit-drop-sprite-id">${dropSpriteOptions}</select>
                    </div>
                    <div class="modal-buttons">
                        <button id="cancel-edit-btn" class="modal-btn">Hủy</button>
                        <button id="save-edit-monster-btn" class="modal-btn primary">Lưu</button>
                    </div>
                `;
                document.getElementById('cancel-edit-btn').onclick = () => this.renderDetails(monster);
                document.getElementById('save-edit-monster-btn').onclick = () => {
                    const updatedData = {
                        name: document.getElementById('edit-monster-name').value,
                        hp: parseInt(document.getElementById('edit-monster-hp').value),
                        atk: parseInt(document.getElementById('edit-monster-atk').value),
                        spriteId: document.getElementById('edit-monster-sprite-id').value,
                        specialSkill: {
                            name: document.getElementById('edit-skill-name').value,
                            damage: parseInt(document.getElementById('edit-skill-damage').value),
                            chance: parseFloat(document.getElementById('edit-skill-chance').value)
                        },
                        dropItem: {
                            name: document.getElementById('edit-drop-name').value,
                            dropRate: parseFloat(document.getElementById('edit-drop-rate').value),
                            spriteId: document.getElementById('edit-drop-sprite-id').value || null
                        }
                    };

                    if (monsterManager.update(monster.name, updatedData)) {
                        alert('Đã cập nhật!');
                        this.renderList();
                        this.renderDetails(monsterManager.monsters.find(m => m.name === updatedData.name));
                    }
                };
            }
        };

        const spellModal = {
            listEl: document.getElementById('spell-list'),
            detailsEl: document.getElementById('spell-details-panel'),
            renderList() {
                this.listEl.innerHTML = '';
                const addLi = document.createElement('li');
                addLi.textContent = '[+] Thêm Phép Thuật Mới';
                addLi.className = 'add-item-btn';
                addLi.onclick = () => {
                    this.renderAddForm();
                    document.querySelectorAll('#spell-list li').forEach(el => el.classList.remove('selected'));
                    addLi.classList.add('selected');
                };
                this.listEl.appendChild(addLi);
                spellManager.spells.forEach(spell => {
                    const li = document.createElement('li');
                    li.textContent = spell.name;
                    li.onclick = () => {
                        this.renderDetails(spell);
                        document.querySelectorAll('#spell-list li').forEach(el => el.classList.remove('selected'));
                        li.classList.add('selected');
                    };
                    this.listEl.appendChild(li);
                });
                this.renderAddForm(); // Default to add form
                addLi.classList.add('selected');
            },
            renderDetails(spell) {
                const sprite = spell.spriteId ? imageManager.getImageById(spell.spriteId) : null;
                this.detailsEl.innerHTML = `
                    <h3>${spell.name}</h3>
                    <p>MP Tiêu hao: ${spell.mpCost}</p>
                    <p>Sát thương: ${spell.damage}</p>
                    <p>Màu hiệu ứng: <span style="background-color: ${spell.effectColor}; padding: 0 5px; border: 1px solid #fff;">${spell.effectColor}</span></p>
                    <p>Số lần nháy màn hình: ${spell.flashes}</p>
                    <p>Hình ảnh hiệu ứng: ${sprite ? `<img src="${sprite.url}" class="detail-view"> (${sprite.name})` : 'Không có'}</p>
                    <p>Số lần nháy hình ảnh: ${spell.spriteFlashes}</p>
                    <div class="modal-buttons">
                        <button id="edit-spell-btn" class="modal-btn">Chỉnh Sửa</button>
                        <button id="delete-spell-btn" class="modal-btn danger">Xóa</button>
                    </div>
                `;
                document.getElementById('edit-spell-btn').onclick = () => this.renderEditForm(spell);
                document.getElementById('delete-spell-btn').onclick = () => {
                    if (confirm(`Bạn có chắc muốn xóa phép thuật ${spell.name}?`)) {
                        spellManager.delete(spell.id);
                        this.renderList();
                    }
                }
            },
            renderAddForm() {
                let spriteOptions = '<option value="">Không có</option>';
                imageManager.images.forEach(img => {
                    spriteOptions += `<option value="${img.id}">${img.name}</option>`;
                });
                this.detailsEl.innerHTML = `
                    <h3>Thêm Phép Thuật Mới</h3>
                    <div class="input-group"><label>Tên:</label><input type="text" id="new-spell-name" required></div>
                    <div class="input-group"><label>MP Tiêu hao:</label><input type="number" id="new-spell-mpcost" value="5" required></div>
                    <div class="input-group"><label>Sát thương:</label><input type="number" id="new-spell-damage" value="20" required></div>
                    <div class="input-group"><label>Màu hiệu ứng (Hex/Tên):</label><input type="color" id="new-spell-effectcolor" value="#00ffff" required></div>
                    <div class="input-group"><label>Số lần nháy màn hình:</label><input type="number" id="new-spell-flashes" value="3" min="0" required></div>
                    <div class="input-group">
                        <label for="new-spell-sprite-id">Chọn ảnh hiệu ứng:</label>
                        <select id="new-spell-sprite-id">${spriteOptions}</select>
                    </div>
                    <div class="input-group"><label>Số lần nháy hình ảnh:</label><input type="number" id="new-spell-spriteflashes" value="0" min="0" required></div>
                    <div class="modal-buttons"><button id="save-new-spell-btn" class="modal-btn primary">Lưu</button></div>
                `;
                document.getElementById('save-new-spell-btn').onclick = () => {
                    const name = document.getElementById('new-spell-name').value;
                    const mpCost = parseInt(document.getElementById('new-spell-mpcost').value);
                    const damage = parseInt(document.getElementById('new-spell-damage').value);
                    const effectColor = document.getElementById('new-spell-effectcolor').value;
                    const flashes = parseInt(document.getElementById('new-spell-flashes').value);
                    const spriteId = document.getElementById('new-spell-sprite-id').value || null;
                    const spriteFlashes = parseInt(document.getElementById('new-spell-spriteflashes').value);

                    if (!name || isNaN(mpCost) || isNaN(damage) || !effectColor || isNaN(flashes) || isNaN(spriteFlashes)) {
                        alert('Vui lòng điền đủ thông tin.');
                        return;
                    }

                    const newSpell = {
                        id: name, // Using name as ID
                        name,
                        mpCost,
                        damage,
                        effectColor,
                        flashes,
                        spriteId,
                        spriteFlashes
                    };
                    if (spellManager.add(newSpell)) {
                        alert('Đã thêm phép thuật!');
                        this.renderList();
                        menuManager.populateMagicMenu(); // Update magic menu in game
                    }
                };
            },
            renderEditForm(spell) {
                let spriteOptions = '<option value="">Không có</option>';
                imageManager.images.forEach(img => {
                    spriteOptions += `<option value="${img.id}" ${img.id === spell.spriteId ? 'selected' : ''}>${img.name}</option>`;
                });
                this.detailsEl.innerHTML = `
                    <h3>Chỉnh sửa: ${spell.name}</h3>
                    <div class="input-group"><label>Tên:</label><input type="text" id="edit-spell-name" value="${spell.name}" required></div>
                    <div class="input-group"><label>MP Tiêu hao:</label><input type="number" id="edit-spell-mpcost" value="${spell.mpCost}" required></div>
                    <div class="input-group"><label>Sát thương:</label><input type="number" id="edit-spell-damage" value="${spell.damage}" required></div>
                    <div class="input-group"><label>Màu hiệu ứng (Hex/Tên):</label><input type="color" id="edit-spell-effectcolor" value="${spell.effectColor}" required></div>
                    <div class="input-group"><label>Số lần nháy màn hình:</label><input type="number" id="edit-spell-flashes" value="${spell.flashes}" min="0" required></div>
                    <div class="input-group">
                        <label for="edit-spell-sprite-id">Chọn ảnh hiệu ứng:</label>
                        <select id="edit-spell-sprite-id">${spriteOptions}</select>
                    </div>
                    <div class="input-group"><label>Số lần nháy hình ảnh:</label><input type="number" id="edit-spell-spriteflashes" value="${spell.spriteFlashes}" min="0" required></div>
                    <div class="modal-buttons">
                        <button id="cancel-edit-btn" class="modal-btn">Hủy</button>
                        <button id="save-edit-spell-btn" class="modal-btn primary">Lưu</button>
                    </div>
                `;
                document.getElementById('cancel-edit-btn').onclick = () => this.renderDetails(spell);
                document.getElementById('save-edit-spell-btn').onclick = () => {
                    const updatedData = {
                        name: document.getElementById('edit-spell-name').value,
                        mpCost: parseInt(document.getElementById('edit-spell-mpcost').value),
                        damage: parseInt(document.getElementById('edit-spell-damage').value),
                        effectColor: document.getElementById('edit-spell-effectcolor').value,
                        flashes: parseInt(document.getElementById('edit-spell-flashes').value),
                        spriteId: document.getElementById('edit-spell-sprite-id').value || null,
                        spriteFlashes: parseInt(document.getElementById('edit-spell-spriteflashes').value)
                    };

                    if (spellManager.update(spell.id, updatedData)) {
                        alert('Đã cập nhật!');
                        this.renderList();
                        this.renderDetails(spellManager.spells.find(s => s.id === updatedData.name));
                        menuManager.populateMagicMenu(); // Update magic menu in game
                    }
                };
            }
        };

        // NEW: Image Manager Modal Implementation
        const imageManagerModal = {
            listEl: document.getElementById('image-list'),
            detailsEl: document.getElementById('image-details-panel'),
            renderList() {
                this.listEl.innerHTML = '';
                const addLi = document.createElement('li');
                addLi.textContent = '[+] Thêm Hình Ảnh Mới';
                addLi.className = 'add-item-btn';
                addLi.onclick = () => {
                    this.renderAddForm();
                    document.querySelectorAll('#image-list li').forEach(el => el.classList.remove('selected'));
                    addLi.classList.add('selected');
                };
                this.listEl.appendChild(addLi);

                imageManager.images.forEach(img => {
                    const li = document.createElement('li');
                    li.textContent = img.name;
                    li.dataset.imageId = img.id;
                    li.onclick = () => {
                        this.renderDetails(img);
                        document.querySelectorAll('#image-list li').forEach(el => el.classList.remove('selected'));
                        li.classList.add('selected');
                    };
                    this.listEl.appendChild(li);
                });
                this.renderAddForm(); // Default to add form
                addLi.classList.add('selected');
            },
            renderDetails(image) {
                this.detailsEl.innerHTML = `
                    <h3>${image.name}</h3>
                    <div class="image-detail-view">
                        <img src="${image.url}" alt="${image.name}">
                    </div>
                    <p><strong>ID:</strong> ${image.id}</p>
                    <p><strong>URL:</strong> ${image.url}</p>
                    <p><strong>Là Sprite Sheet:</strong> ${image.isSpriteSheet ? 'Có' : 'Không'}</p>
                    ${image.isSpriteSheet ? `
                        <p><strong>Rộng Khung:</strong> ${image.frameWidth}px</p>
                        <p><strong>Cao Khung:</strong> ${image.frameHeight}px</p>
                        <p><strong>Khung mỗi dòng:</strong> ${image.framesPerRow}</p>
                        <p><strong>Dòng hoạt ảnh:</strong> ${image.animationRow} (0-indexed)</p>
                        <p><strong>Tốc độ hoạt ảnh:</strong> ${image.animationSpeed}ms/khung</p>
                        <p><strong>Tổng số dòng:</strong> ${image.totalRows}</p>
                    ` : ''}
                    <div class="modal-buttons">
                        <button id="edit-image-btn" class="modal-btn">Chỉnh Sửa</button>
                        <button id="delete-image-btn" class="modal-btn danger">Xóa</button>
                    </div>
                `;
                document.getElementById('edit-image-btn').onclick = () => this.renderEditForm(image);
                document.getElementById('delete-image-btn').onclick = () => {
                    if (confirm(`Bạn có chắc muốn xóa hình ảnh "${image.name}"?`)) {
                        imageManager.delete(image.id);
                        this.renderList();
                    }
                }
            },
            renderAddForm() {
                this.detailsEl.innerHTML = `
                    <h3>Thêm Hình Ảnh Mới</h3>
                    <div class="input-group"><label>ID (duy nhất):</label><input type="text" id="new-image-id" required></div>
                    <div class="input-group"><label>Tên:</label><input type="text" id="new-image-name" required></div>
                    <div class="input-group"><label>Tải file lên:</label><input type="file" id="new-image-file" accept="image/png,image/gif"></div>
                    <div class="input-group-divider">hoặc</div>
                    <div class="input-group"><label>Dán URL ảnh:</label><input type="text" id="new-image-url" placeholder="https://..." required></div>
                    <div class="input-group"><label>Là Sprite Sheet?</label><input type="checkbox" id="new-image-is-sprite-sheet"></div>
                    <div id="new-sprite-sheet-config" style="display: none;">
                        <div class="input-group"><label>Rộng Khung (px):</label><input type="number" id="new-image-frame-width" value="16" min="1"></div>
                        <div class="input-group"><label>Cao Khung (px):</label><input type="number" id="new-image-frame-height" value="16" min="1"></div>
                        <div class="input-group"><label>Khung mỗi dòng:</label><input type="number" id="new-image-frames-per-row" value="1" min="1"></div>
                        <div class="input-group"><label>Dòng hoạt ảnh (0-indexed):</label><input type="number" id="new-image-animation-row" value="0" min="0"></div>
                        <div class="input-group"><label>Tốc độ hoạt ảnh (ms/khung):</label><input type="number" id="new-image-animation-speed" value="100" min="1"></div>
                        <div class="input-group"><label>Tổng số dòng (ước tính):</label><input type="number" id="new-image-total-rows" value="1" min="1"></div>
                    </div>
                    <div class="modal-buttons"><button id="save-new-image-btn" class="modal-btn primary">Lưu</button></div>
                `;
                const isSpriteSheetCheckbox = document.getElementById('new-image-is-sprite-sheet');
                const spriteSheetConfigDiv = document.getElementById('new-sprite-sheet-config');
                isSpriteSheetCheckbox.addEventListener('change', () => {
                    spriteSheetConfigDiv.style.display = isSpriteSheetCheckbox.checked ? 'block' : 'none';
                });

                document.getElementById('save-new-image-btn').onclick = () => {
                    const id = document.getElementById('new-image-id').value;
                    const name = document.getElementById('new-image-name').value;
                    const isSpriteSheet = isSpriteSheetCheckbox.checked;

                    const frameWidth = parseInt(document.getElementById('new-image-frame-width').value);
                    const frameHeight = parseInt(document.getElementById('new-image-frame-height').value);
                    const framesPerRow = parseInt(document.getElementById('new-image-frames-per-row').value);
                    const animationRow = parseInt(document.getElementById('new-image-animation-row').value);
                    const animationSpeed = parseInt(document.getElementById('new-image-animation-speed').value);
                    const totalRows = parseInt(document.getElementById('new-image-total-rows').value);


                    if (!id || !name) {
                        alert('Vui lòng điền ID và Tên hình ảnh.');
                        return;
                    }
                    if (isSpriteSheet && (isNaN(frameWidth) || isNaN(frameHeight) || isNaN(framesPerRow) || isNaN(animationRow) || isNaN(animationSpeed) || isNaN(totalRows))) {
                        alert('Vui lòng điền đầy đủ thông tin Sprite Sheet.');
                        return;
                    }

                    getImageUrlFromFileOrUrl(
                        document.getElementById('new-image-url'),
                        document.getElementById('new-image-file'),
                        (spriteUrl) => {
                            if (!spriteUrl) {
                                alert('Vui lòng cung cấp URL hoặc tải file ảnh lên.');
                                return;
                            }
                            const newImage = {
                                id: id,
                                name: name,
                                url: spriteUrl,
                                isSpriteSheet: isSpriteSheet,
                                frameWidth: isSpriteSheet ? frameWidth : 16,
                                frameHeight: isSpriteSheet ? frameHeight : 16,
                                framesPerRow: isSpriteSheet ? framesPerRow : 1,
                                animationRow: isSpriteSheet ? animationRow : 0,
                                animationSpeed: isSpriteSheet ? animationSpeed : 100,
                                totalRows: isSpriteSheet ? totalRows : 1
                            };
                            if (imageManager.add(newImage)) {
                                alert('Đã thêm hình ảnh!');
                                this.renderList();
                                customizeModal.populateSpriteSelect(); // Update player sprite dropdown
                            }
                        }
                    );
                };
            },
            renderEditForm(image) {
                this.detailsEl.innerHTML = `
                    <h3>Chỉnh sửa: ${image.name}</h3>
                    <div class="input-group"><label>ID (duy nhất):</label><input type="text" id="edit-image-id" value="${image.id}" required ${imageManager.defaultImages.some(img => img.id === image.id) ? 'readonly' : ''}></div>
                    <div class="input-group"><label>Tên:</label><input type="text" id="edit-image-name" value="${image.name}" required></div>
                    <div class="input-group"><label>Tải file mới (tùy chọn):</label><input type="file" id="edit-image-file" accept="image/png,image/gif"></div>
                    <div class="input-group-divider">hoặc</div>
                    <div class="input-group"><label>URL ảnh mới:</label><input type="text" id="edit-image-url" placeholder="Để trống nếu không đổi" value="${image.url}"></div>
                    <div class="input-group"><label>Là Sprite Sheet?</label><input type="checkbox" id="edit-image-is-sprite-sheet" ${image.isSpriteSheet ? 'checked' : ''}></div>
                    <div id="edit-sprite-sheet-config" style="display: ${image.isSpriteSheet ? 'block' : 'none'};">
                        <div class="input-group"><label>Rộng Khung (px):</label><input type="number" id="edit-image-frame-width" value="${image.frameWidth}" min="1"></div>
                        <div class="input-group"><label>Cao Khung (px):</label><input type="number" id="edit-image-frame-height" value="${image.frameHeight}" min="1"></div>
                        <div class="input-group"><label>Khung mỗi dòng:</label><input type="number" id="edit-image-frames-per-row" value="${image.framesPerRow}" min="1"></div>
                        <div class="input-group"><label>Dòng hoạt ảnh (0-indexed):</label><input type="number" id="edit-image-animation-row" value="${image.animationRow}" min="0"></div>
                        <div class="input-group"><label>Tốc độ hoạt ảnh (ms/khung):</label><input type="number" id="edit-image-animation-speed" value="${image.animationSpeed}" min="1"></div>
                        <div class="input-group"><label>Tổng số dòng (ước tính):</label><input type="number" id="edit-image-total-rows" value="${image.totalRows}" min="1"></div>
                    </div>
                    <div class="modal-buttons">
                        <button id="cancel-edit-btn" class="modal-btn">Hủy</button>
                        <button id="save-edit-image-btn" class="modal-btn primary">Lưu</button>
                    </div>
                `;
                const isSpriteSheetCheckbox = document.getElementById('edit-image-is-sprite-sheet');
                const spriteSheetConfigDiv = document.getElementById('edit-sprite-sheet-config');
                isSpriteSheetCheckbox.addEventListener('change', () => {
                    spriteSheetConfigDiv.style.display = isSpriteSheetCheckbox.checked ? 'block' : 'none';
                });

                document.getElementById('cancel-edit-btn').onclick = () => this.renderDetails(image);
                document.getElementById('save-edit-image-btn').onclick = () => {
                    const originalId = image.id;
                    const updatedData = {
                        id: document.getElementById('edit-image-id').value,
                        name: document.getElementById('edit-image-name').value,
                        isSpriteSheet: isSpriteSheetCheckbox.checked,
                        frameWidth: parseInt(document.getElementById('edit-image-frame-width').value),
                        frameHeight: parseInt(document.getElementById('edit-image-frame-height').value),
                        framesPerRow: parseInt(document.getElementById('edit-image-frames-per-row').value),
                        animationRow: parseInt(document.getElementById('edit-image-animation-row').value),
                        animationSpeed: parseInt(document.getElementById('edit-image-animation-speed').value),
                        totalRows: parseInt(document.getElementById('edit-image-total-rows').value)
                    };

                    getImageUrlFromFileOrUrl(
                        document.getElementById('edit-image-url'),
                        document.getElementById('edit-image-file'),
                        (newSpriteUrl) => {
                            if (newSpriteUrl) updatedData.url = newSpriteUrl; // Only update URL if new one is provided
                            else updatedData.url = image.url; // Keep existing URL if no new file/url

                            if (imageManager.update(originalId, updatedData)) {
                                alert('Đã cập nhật!');
                                this.renderList();
                                this.renderDetails(imageManager.getImageById(updatedData.id)); // Re-render details with potentially new ID
                                customizeModal.populateSpriteSelect(); // Update player sprite dropdown
                            }
                        }
                    );
                };
            }
        };
        
        function setupTabs() { const tabButtons = document.querySelectorAll('#stats-modal .tab-btn'); const tabPanes = document.querySelectorAll('#stats-modal .tab-pane'); tabButtons.forEach(button => { button.addEventListener('click', () => { tabButtons.forEach(btn => btn.classList.remove('active')); tabPanes.forEach(pane => pane.classList.remove('active')); button.classList.add('active'); const tabId = button.dataset.tab; document.getElementById(tabId).classList.add('active'); if (tabId === 'tab-char-info') populateCharInfoTab(); if (tabId === 'tab-magic') populateMagicTab(); if (tabId === 'tab-inventory') populateInventoryTab(); }); }); }
        function populateCharInfoTab() { const stats = playerDataManager.stats; let currentHp = stats.maxHp; let currentMp = stats.mp; if (playerUnit) { currentHp = playerUnit.hp; currentMp = playerUnit.mp; } document.getElementById('tab-char-info').innerHTML = `<h3>Trạng Thái</h3><p><strong>Cấp Độ:</strong> ${stats.level}</p><p><strong>HP:</strong> ${currentHp} / ${stats.maxHp}</p><p><strong>MP:</strong> ${currentMp} / ${stats.maxMp}</p><p><strong>Sức Tấn Công (ATK):</strong> ${stats.atk}</p><hr><p><strong>Số trận đã thắng:</strong> ${stats.battlesWon}</p><p><strong>Cần thắng để lên cấp:</strong> ${stats.battlesToNextLevel - stats.battlesWon}</p>`; }
        function populateMagicTab() { let content = '<h3>Phép Thuật</h3><ul class="magic-list">'; if (spellManager.spells.length === 0) { content += '<li>Chưa học được phép nào.</li>'; } else { spellManager.spells.forEach(spell => { content += `<li><strong>${spell.name}</strong> (MP: ${spell.mpCost}, Sát thương: ${spell.damage})</li>`; }); } content += '</ul>'; document.getElementById('tab-magic').innerHTML = content; }
        function populateInventoryTab() { let content = '<h3>Túi Đồ</h3><ul class="inventory-list">'; const items = Object.keys(inventoryManager.items); if (items.length === 0) { content += '<li>Túi đồ trống.</li>'; } else { items.forEach(itemName => { content += `<li><strong>${itemName}</strong> x ${inventoryManager.items[itemName]}</li>`; }); } content += '</ul>'; document.getElementById('tab-inventory').innerHTML = content; }

        playerDataManager.load();
        monsterManager.load();
        spellManager.load();
        inventoryManager.load();
        imageManager.load(); // NEW: Load image data
        setupTabs();

        // ===================================
        // LOGIC CHO MÀN HÌNH GAME CHÍNH
        // ===================================
        function initializeMainGame() {
            const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d'), TILE_SIZE = 16, MAP_WIDTH_TILES = 40, MAP_HEIGHT_TILES = 30;
            canvas.width = TILE_SIZE * MAP_WIDTH_TILES; canvas.height = TILE_SIZE * MAP_HEIGHT_TILES;
            let gameState = 'world', battleState = '', gameStarted = false, battleBackgroundColor = '#333', currentAnimation = null, enemyUnits = [], turnOrder = [], currentTurnIndex = 0, selectedTargetIndex = 0, pendingPlayerAction = null;
            const keys = {};

            const spriteManager = {
                spriteData: {},
                defaultPlayerDataId: 'player_default', // Use ID from imageManager
                loadAll(callback) {
                    const playerAssetId = localStorage.getItem('custom_sprite_player_id') || this.defaultPlayerDataId;
                    const playerSpriteInfo = imageManager.getImageById(playerAssetId);
                    const playerConfig = localStorage.getItem('custom_sprite_player_config');

                    if (playerConfig) {
                        Object.assign(playerSpriteConfig, JSON.parse(playerConfig));
                    } else if (playerSpriteInfo) {
                        Object.assign(playerSpriteConfig, {
                            isSpriteSheet: playerSpriteInfo.isSpriteSheet,
                            frameWidth: playerSpriteInfo.frameWidth,
                            frameHeight: playerSpriteInfo.frameHeight,
                            framesPerRow: playerSpriteInfo.framesPerRow,
                            animationRow: playerSpriteInfo.animationRow,
                            animationSpeed: playerSpriteInfo.animationSpeed,
                            totalRows: playerSpriteInfo.totalRows
                        });
                    }

                    const assetsToLoad = {
                        [playerAssetId]: playerSpriteInfo ? playerSpriteInfo.url : imageManager.getImageById(this.defaultPlayerDataId).url,
                    };

                    // Load monster sprites based on spriteId
                    monsterManager.monsters.forEach(m => {
                        const img = imageManager.getImageById(m.spriteId);
                        if (img) assetsToLoad[m.spriteId] = img.url;
                    });
                    // Load spell sprites based on spriteId
                    spellManager.spells.forEach(s => {
                        if (s.spriteId) {
                            const img = imageManager.getImageById(s.spriteId);
                            if (img) assetsToLoad[s.spriteId] = img.url;
                        }
                    });
                    // Load item sprites based on spriteId if they exist in monster drops
                    monsterManager.monsters.forEach(m => {
                        if (m.dropItem && m.dropItem.spriteId) {
                            const img = imageManager.getImageById(m.dropItem.spriteId);
                            if (img) assetsToLoad[m.dropItem.spriteId] = img.url;
                        }
                    });


                    const assetKeys = Object.keys(assetsToLoad);
                    let assetsLeft = assetKeys.length;

                    if (assetsLeft === 0) { if(callback) callback(); return; }

                    const onAssetLoaded = () => {
                        if (--assetsLeft === 0) if(callback) callback();
                    };

                    assetKeys.forEach(key => {
                        const url = assetsToLoad[key];
                        if (!url) { onAssetLoaded(); return; }

                        if (url.startsWith('data:image/gif') || url.endsWith('.gif')) { // Check for .gif extension too
                            const offscreenCanvas = document.createElement('canvas');
                            this.spriteData[key] = { type: 'gif', asset: offscreenCanvas, loaded: false };
                            const sprite = this.spriteData[key];
                            gifler(url).frames(offscreenCanvas, (ctx, frame) => {
                                if (!sprite.loaded) {
                                    offscreenCanvas.width = frame.width;
                                    offscreenCanvas.height = frame.height;
                                    sprite.loaded = true;
                                    onAssetLoaded();
                                }
                                ctx.clearRect(0, 0, frame.width, frame.height);
                                ctx.drawImage(frame.buffer, frame.x, frame.y);
                            });
                        } else {
                            this.spriteData[key] = { type: 'static', asset: new Image(), loaded: false };
                            const sprite = this.spriteData[key];
                            sprite.asset.crossOrigin = "Anonymous";
                            sprite.asset.onload = () => {
                                sprite.loaded = true;
                                onAssetLoaded();
                            };
                            sprite.asset.onerror = () => {
                                console.error(`Không thể tải hình ảnh: ${url}`);
                                sprite.loaded = false;
                                onAssetLoaded();
                            };
                            sprite.asset.src = url;
                        }
                    });
                },
                draw(key, x, y, width, height) {
                    const sprite = this.spriteData[key];
                    if (sprite && sprite.loaded) {
                        // Determine if this specific key (e.g., player) has sprite sheet config
                        let currentConfig = null;
                        if (key === localStorage.getItem('custom_sprite_player_id') || key === this.defaultPlayerDataId) {
                            currentConfig = playerSpriteConfig;
                        } else {
                            // For monsters/spells, get their specific config from imageManager if it's a sprite sheet
                            const imageInfo = imageManager.getImageById(key);
                            if (imageInfo && imageInfo.isSpriteSheet) {
                                currentConfig = imageInfo; // Using imageInfo directly as config for non-player sprites
                            }
                        }

                        if (currentConfig && currentConfig.isSpriteSheet) {
                            const { frameWidth, frameHeight, currentFrame, animationRow } = currentConfig;
                            const sx = currentFrame * frameWidth;
                            const sy = animationRow * frameHeight;
                            ctx.drawImage(sprite.asset, sx, sy, frameWidth, frameHeight, x, y, width, height);
                        } else {
                            ctx.drawImage(sprite.asset, x, y, width, height);
                        }
                    } else {
                        ctx.fillStyle = '#FF00FF'; // Magenta placeholder for missing/unloaded sprite
                        ctx.fillRect(x, y, width, height);
                    }
                }
            };

            window.addEventListener('keydown', e => keys[e.key] = true); window.addEventListener('keyup', e => keys[e.key] = false);
            function setupDPadListeners() { const dPadButtons = { 'd-pad-up': 'ArrowUp', 'd-pad-down': 'ArrowDown', 'd-pad-left': 'ArrowLeft', 'd-pad-right': 'ArrowRight', }; for (const [buttonId, key] of Object.entries(dPadButtons)) { const button = document.getElementById(buttonId); if(!button) continue; button.addEventListener('mousedown', (e) => { e.preventDefault(); keys[key] = true; }); button.addEventListener('mouseup', (e) => { e.preventDefault(); keys[key] = false; }); button.addEventListener('mouseleave', (e) => { e.preventDefault(); keys[key] = false; }); button.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, { passive: false }); button.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, { passive: false }); } }
            const map = { layout: [], colors: { 0: '#A0522D', 1: '#228B22', 2: '#0000CD' }, generate() { let grid, waterPercentage; do { grid = Array.from({ length: MAP_HEIGHT_TILES }, () => Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? 2 : 0)); for (let i = 0; i < 4; i++) { let newGrid = JSON.parse(JSON.stringify(grid)); for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) { for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) { let waterNeighbors = 0; for (let ny = y - 1; ny <= y + 1; ny++) for (let nx = x - 1; nx <= x + 1; nx++) if (grid[ny][nx] === 2) waterNeighbors++; if (waterNeighbors > 4) newGrid[y][x] = 2; else if (waterNeighbors < 4) newGrid[y][x] = 0; } } grid = newGrid; } const visited = Array.from({ length: MAP_HEIGHT_TILES }, () => Array(MAP_WIDTH_TILES).fill(false)); const startNode = {x: 1, y: 1}; if (grid[startNode.y][startNode.x] === 2) grid[startNode.y][startNode.x] = 0; const queue = [startNode]; visited[startNode.y][startNode.x] = true; let head = 0; while (head < queue.length) { const {x, y} = queue[head++]; const neighbors = [{x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}]; for (const n of neighbors) { if (n.x >= 0 && n.x < MAP_WIDTH_TILES && n.y >= 0 && n.y < MAP_HEIGHT_TILES && !visited[n.y][n.x] && grid[n.y][n.x] !== 2) { visited[n.y][n.x] = true; queue.push(n); } } } for(let y=0; y<MAP_HEIGHT_TILES; y++) for(let x=0; x<MAP_WIDTH_TILES; x++) if(!visited[y][x]) grid[y][x] = 2; for(let y=0; y<MAP_HEIGHT_TILES; y++) for(let x=0; x<MAP_WIDTH_TILES; x++) if(x===0||x===MAP_WIDTH_TILES-1||y===0||y===MAP_HEIGHT_TILES-1) if(grid[y][x]===2)grid[y][x]=0; let waterCount = grid.flat().filter(tile => tile === 2).length; waterPercentage = waterCount / (MAP_WIDTH_TILES * MAP_HEIGHT_TILES); } while (waterPercentage > 0.5); for (let y=0; y<MAP_HEIGHT_TILES; y++) for (let x=0; x<MAP_WIDTH_TILES; x++) if (grid[y][x] === 0 && Math.random() > 0.6) grid[y][x] = 1; this.layout = grid; }, draw() { for (let y=0; y<MAP_HEIGHT_TILES; y++) for (let x=0; x<MAP_WIDTH_TILES; x++) { ctx.fillStyle = this.colors[this.layout[y][x]]; ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE); } }, isSolid: (x, y) => map.layout[y][x] === 2, isEncounterZone: (x, y) => map.layout[y][x] === 1 };
            const player = { x: 10, y: 10, moveCooldown: 120, lastMoveTime: 0,
                // MODIFIED draw for player
                draw() {
                    const spriteSize = TILE_SIZE; // Player is TILE_SIZE x TILE_SIZE in world map
                    const playerSpriteId = localStorage.getItem('custom_sprite_player_id') || spriteManager.defaultPlayerDataId;
                    spriteManager.draw(playerSpriteId, this.x * spriteSize, this.y * spriteSize, spriteSize, spriteSize);
                },
                handleMovement() { if (document.querySelector('.modal[style*="flex"]')) return; if(Date.now()-this.lastMoveTime<this.moveCooldown)return; let dx=0,dy=0; if(keys['ArrowUp']||keys['w'])dy=-1;else if(keys['ArrowDown']||keys['s'])dy=1;else if(keys['ArrowLeft']||keys['a'])dx=-1;else if(keys['ArrowRight']||keys['d'])dx=1; if(dx===0&&dy===0)return; this.lastMoveTime=Date.now(); const newX=this.x+dx,newY=this.y+dy; if(newX<0||newX>=MAP_WIDTH_TILES||newY<0||newY>=MAP_HEIGHT_TILES){map.generate();this.x=10;this.y=10;return;} if(!map.isSolid(newX, newY)){this.x=newX;this.y=newY;if(map.isEncounterZone(this.x,this.y))checkRandomEncounter();} } };
            class Unit { constructor(name, baseName, hp, maxHp, atk, level=null, mp=null, maxMp=null, specialSkill = null, spriteId = null) { this.name = name; this.baseName = baseName; this.hp = hp; this.maxHp = maxHp; this.atk = atk; this.level = level; this.mp = mp; this.maxMp = maxMp; this.specialSkill = specialSkill; this.isPlayer = (level !== null); this.spriteId = spriteId || baseName; } attack(target) { const damage = Math.floor(this.atk * (0.8 + Math.random() * 0.4)); target.hp = Math.max(0, target.hp - damage); return `${this.name} tấn công ${target.name}, gây ${damage} sát thương!`; } }
            const menuManager = { currentMenu: 'main', lastInputTime: 0, menus: { main: { el: ui.battleMenu, selectedIndex: 0 }, magic: { el: ui.magicMenu, selectedIndex: 0 } }, init() { const mainOptions = this.menus.main.el.querySelectorAll('li'); mainOptions.forEach((li, index) => { li.addEventListener('click', (e) => { e.stopPropagation(); if (battleState === 'processing' || this.currentMenu !== 'main') return; this.menus.main.selectedIndex = index; this.select(); }); li.addEventListener('mouseenter', () => { if (battleState === 'playerTurn') this.menus.main.selectedIndex = index; }); }); }, update() { if (Date.now() - this.lastInputTime < 150) return; const menu = this.menus[this.currentMenu]; const options = menu.el.querySelectorAll('li'); if (options.length === 0) return; let actionTaken = false; if (keys['ArrowUp']) { menu.selectedIndex = (menu.selectedIndex - 1 + options.length) % options.length; actionTaken = true; } else if (keys['ArrowDown']) { menu.selectedIndex = (menu.selectedIndex + 1) % options.length; actionTaken = true; } else if (keys['Enter'] || keys[' ']) { this.select(); actionTaken = true; } if (actionTaken) this.lastInputTime = Date.now(); }, draw() { for (const menuKey in this.menus) { const menu = this.menus[menuKey]; const options = menu.el.querySelectorAll('li'); options.forEach((li, i) => li.classList.toggle('selected', i === menu.selectedIndex)); } }, select() { const menu = this.menus[this.currentMenu]; const selectedOption = menu.el.querySelectorAll('li')[menu.selectedIndex]; if (this.currentMenu === 'main') { const action = selectedOption.dataset.action; if (action === 'attack') { pendingPlayerAction = { type: 'attack' }; battleState = 'playerTargeting'; } else if (action === 'magic') { this.switchMenu('magic'); battleState = 'playerChoosingSpell'; } else if (action === 'flee') { battleState = 'processing'; updateInfoPanel(''); showMessage("Bạn đã bỏ chạy thành công!", () => {endBattle(); gameState='world';}); } } else if (this.currentMenu === 'magic') { const spellId = selectedOption.dataset.spell; if (spellId === 'back') { this.switchMenu('main'); battleState = 'playerTurn'; } else { pendingPlayerAction = { type: 'spell', spellId: spellId }; battleState = 'playerTargeting'; this.switchMenu('main'); } } }, castSpell(spellId, target) { updateInfoPanel(''); const spell = spellManager.spells.find(s => s.id === spellId); if (!spell) { console.error(`Spell ${spellId} not found!`); advanceTurn(); return; } if (playerUnit.mp < spell.mpCost) { showMessage("Không đủ MP!", () => { battleState = 'playerTurn'; }); return; } playerUnit.mp -= spell.mpCost; target.hp = Math.max(0, target.hp - spell.damage); const onAnimationComplete = () => { const msg = `Dùng ${spell.name} lên ${target.name}, gây ${spell.damage} sát thương!`; showMessage(msg, () => { checkBattleEnd(); if (gameState === 'battle') advanceTurn(); }); }; playSpellAnimation(spell, target, onAnimationComplete); }, switchMenu(menuKey) { this.menus[this.currentMenu].el.style.display = 'none'; this.currentMenu = menuKey; this.menus[this.currentMenu].el.style.display = 'block'; this.menus[this.currentMenu].selectedIndex = 0; }, getCurrentDescription() { const menu = this.menus[this.currentMenu]; const selectedOption = menu.el.querySelectorAll('li')[menu.selectedIndex]; return selectedOption ? selectedOption.dataset.description : ''; }, populateMagicMenu() { ui.magicMenuList.innerHTML = ''; spellManager.spells.forEach(spell => { const li = document.createElement('li'); li.dataset.spell = spell.id; li.dataset.description = `Gây ${spell.damage} sát thương ${spell.mpCost} MP).`; li.textContent = `${spell.name} (${spell.mpCost} MP)`; ui.magicMenuList.appendChild(li); }); const backLi = document.createElement('li'); backLi.dataset.spell = 'back'; backLi.dataset.description = 'Quay lại menu chính.'; backLi.textContent = 'Quay lại'; ui.magicMenuList.appendChild(backLi); const magicOptions = this.menus.magic.el.querySelectorAll('li'); magicOptions.forEach((li, index) => { li.addEventListener('click', (e) => { e.stopPropagation(); if (battleState === 'processing' || this.currentMenu !== 'magic') return; this.menus.magic.selectedIndex = index; this.select(); }); li.addEventListener('mouseenter', () => { if (battleState === 'playerChoosingSpell') this.menus.magic.selectedIndex = index; }); }); } };
            function updateInfoPanel(text) { if (text && gameState === 'battle') { ui.infoPanel.innerHTML = text; ui.infoPanel.style.display = 'block'; } else { ui.infoPanel.style.display = 'none'; } }
            function startBattle() { if(monsterManager.monsters.length===0) { alert("Không có quái vật nào! Thêm trong mục Quản Lý."); return; } gameState='battle'; const pStats = playerDataManager.stats;
            const playerSpriteId = localStorage.getItem('custom_sprite_player_id') || spriteManager.defaultPlayerDataId;
            playerUnit = new Unit('Anh Hùng', 'Anh Hùng', pStats.maxHp, pStats.maxHp, pStats.atk, pStats.level, pStats.maxMp, pStats.maxMp, null, playerSpriteId);
            enemyUnits = []; turnOrder = []; const enemyCount = Math.floor(Math.random() * 2) + 1; const nameCounter = {}; for (let i = 0; i < enemyCount; i++) { const randomEnemyData = {...monsterManager.monsters[Math.floor(Math.random()*monsterManager.monsters.length)]}; if (!nameCounter[randomEnemyData.name]) nameCounter[randomEnemyData.name] = 0; nameCounter[randomEnemyData.name]++; const displayName = (enemyCount > 1 || Object.keys(nameCounter).length > 1) ? `${randomEnemyData.name} ${String.fromCharCode(65 + i)}` : randomEnemyData.name; const baseName = randomEnemyData.name; const scaledHp = randomEnemyData.hp + (pStats.level * 3 + 20); const newEnemy = new Unit(displayName, baseName, scaledHp, scaledHp, randomEnemyData.atk, null, null, null, randomEnemyData.specialSkill, randomEnemyData.spriteId); enemyUnits.push(newEnemy); } turnOrder = [playerUnit, ...enemyUnits]; currentTurnIndex = 0; selectedTargetIndex = 0; menuManager.populateMagicMenu(); menuManager.switchMenu('main'); ui.playerStatsPanel.style.display='block'; ui.enemyStatsPanel.style.display='block'; const enemyNames = enemyUnits.map(e => e.name).join(', '); showMessage(`Một nhóm ${enemyNames} xuất hiện!`, () => { advanceTurn(); }); updateStatsUI(); }
            function endBattle() { gameState='world'; updateInfoPanel(''); ui.battleMenu.style.display='none';ui.magicMenu.style.display='none';ui.playerStatsPanel.style.display='none';ui.enemyStatsPanel.style.display='none';ui.messageBox.style.display='none'; canvas.classList.remove('targeting'); }
            function checkRandomEncounter() { if(Math.random()<0.15) { const tileType = map.layout[player.y][player.x]; battleBackgroundColor = map.colors[tileType]; startBattle(); } }
            function drawBattleScene() { ctx.fillStyle = battleBackgroundColor; ctx.fillRect(0,0,canvas.width,canvas.height); const battleSpriteSize = TILE_SIZE * 4; spriteManager.draw(playerUnit.spriteId, 100, canvas.height - battleSpriteSize - 80, battleSpriteSize, battleSpriteSize); const enemyStartX = canvas.width - 150 - battleSpriteSize; const enemyStartY = 100; const enemySpacingY = 80; enemyUnits.forEach((enemy, index) => { const x = enemyStartX; const y = enemyStartY + index * enemySpacingY; spriteManager.draw(enemy.spriteId, x, y, battleSpriteSize, battleSpriteSize); }); if (currentAnimation && currentAnimation.type === 'spell') { if (currentAnimation.flashOn) { spriteManager.draw(currentAnimation.spriteId, currentAnimation.x, currentAnimation.y, currentAnimation.size, currentAnimation.size); } } }
            function playSpellAnimation(spell, target, onComplete) {
                const hasSprite = spell.spriteId && spell.spriteFlashes > 0;
                const hasScreenFlash = spell.flashes > 0;
                const executeScreenFlash = () => {
                    if (hasScreenFlash) {
                        playScreenFlash(spell.effectColor, spell.flashes, onComplete);
                    } else {
                        onComplete();
                    }
                };

                if (hasSprite) {
                    const battleSpriteSize = TILE_SIZE * 4;
                    const targetIndex = enemyUnits.indexOf(target);
                    const enemyStartX = canvas.width - 150 - battleSpriteSize;
                    const enemyStartY = 100;
                    const enemySpacingY = 80;
                    const targetX = enemyStartX;
                    const targetY = enemyStartY + targetIndex * enemySpacingY;

                    currentAnimation = {
                        type: 'spell',
                        spriteId: spell.spriteId, // Use spriteId here
                        x: targetX,
                        y: targetY,
                        size: battleSpriteSize,
                        flashOn: true,
                        flashesLeft: spell.spriteFlashes * 2,
                        interval: 120
                    };

                    const animInterval = setInterval(() => {
                        currentAnimation.flashesLeft--;
                        currentAnimation.flashOn = !currentAnimation.flashOn;
                        if (currentAnimation.flashesLeft <= 0) {
                            clearInterval(animInterval);
                            currentAnimation = null;
                            executeScreenFlash();
                        }
                    }, currentAnimation.interval);
                } else {
                    executeScreenFlash();
                }
            }
            function playScreenFlash(color, times, onComplete) { if (times <= 0) { onComplete(); return; } const originalColor = battleBackgroundColor; let flashes = 0; const interval = setInterval(() => { battleBackgroundColor = flashes % 2 === 0 ? color : originalColor; flashes++; if (flashes >= times * 2) { clearInterval(interval); battleBackgroundColor = originalColor; onComplete(); } }, 100); }
            function updateStatsUI() { if(!playerUnit) return; const createPlayerHtml = u => `Anh Hùng-Cấp ${u.level}<br>HP: ${u.hp}/${u.maxHp}<div class="hp-bar-container"><div class="hp-bar" style="width:${(u.hp/u.maxHp*100)}%"></div></div>MP: ${u.mp}/${u.maxMp}<div class="hp-bar-container"><div class="mp-bar" style="width:${(u.mp > 0 ? u.mp/u.maxMp*100 : 0)}%"></div></div>ATK: ${u.atk}`; let enemyHtml = ''; enemyUnits.forEach((u, index) => { enemyHtml += `<div>${selectedTargetIndex === index && battleState === 'playerTargeting' ? '▶ ' : ''}${u.name}<div class="hp-bar-container"><div class="hp-bar" style="width:${u.hp/u.maxHp*100}%"></div></div></div>`; }); ui.playerStatsPanel.innerHTML = createPlayerHtml(playerUnit); ui.enemyStatsPanel.innerHTML = enemyHtml; }
            function showMessage(text, callback) { gameState = 'message'; ui.messageBox.style.display = 'block'; ui.messageText.textContent = ''; ui.nextIndicator.style.display = 'none'; let i = 0, typingInterval = null, isTyping = true, continueListener = null, clickListener = null; const proceed = () => { window.removeEventListener('keydown', continueListener); ui.messageBox.removeEventListener('click', clickListener); ui.nextIndicator.style.display = 'none'; ui.messageBox.style.display = 'none'; if (gameState === 'message') { gameState = 'battle'; } if (callback) { callback(); } }; const finishTyping = () => { if (!isTyping) return; isTyping = false; clearInterval(typingInterval); ui.messageText.textContent = text; ui.nextIndicator.style.display = 'block'; }; const handleInput = (e) => { if (e) e.stopPropagation(); if (isTyping) { finishTyping(); } else { proceed(); } }; continueListener = (e) => { if (e.key === 'Enter' || e.key === ' ') handleInput(); }; clickListener = (e) => handleInput(e); window.addEventListener('keydown', continueListener); ui.messageBox.addEventListener('click', clickListener); typingInterval = setInterval(() => { if (i < text.length) { ui.messageText.textContent += text.charAt(i++); } else { finishTyping(); } }, 30); }
            function handleLevelUp(callback) { playerDataManager.levelUp(); const pStats = playerDataManager.stats; const levelUpMessage = `LEVEL UP! Cấp ${pStats.level}!\nATK+5! HP:${pStats.maxHp} MP:${pStats.maxMp}\nCần ${pStats.battlesToNextLevel} trận để lên cấp.`; showMessage(levelUpMessage, callback); }
            function update() {
                // Update player sprite animation frame
                const playerSpriteInfo = imageManager.getImageById(localStorage.getItem('custom_sprite_player_id') || spriteManager.defaultPlayerDataId);
                if (playerSpriteInfo && playerSpriteInfo.isSpriteSheet && Date.now() - playerSpriteConfig.lastFrameTime > playerSpriteConfig.animationSpeed) {
                    playerSpriteConfig.currentFrame = (playerSpriteConfig.currentFrame + 1) % playerSpriteConfig.framesPerRow;
                    playerSpriteConfig.lastFrameTime = Date.now();
                }

                // Update animation frames for other sprite sheets if needed (e.g., enemy attacks)
                // This would require a more complex animation system for each sprite that's a sheet.
                // For simplicity, we are only animating the player sprite sheet here.

                if(gameState==='world') player.handleMovement();
                else if(gameState==='battle') handleBattleLogic();
            }
            function draw() { ctx.clearRect(0,0,canvas.width,canvas.height); if(gameState==='world'){ updateInfoPanel(''); map.draw(); player.draw(); ui.targetSelector.style.display = 'none'; } else { drawBattleScene(); if (battleState === 'playerTurn' || battleState === 'playerChoosingSpell') { menuManager.draw(); } if (battleState === 'playerTargeting') { updateInfoPanel('Chọn mục tiêu...'); if (enemyUnits.length > 0) { const battleSpriteSize = TILE_SIZE * 4; const enemyStartX = canvas.width - 150 - battleSpriteSize; const enemyStartY = 100; const enemySpacingY = 80; const selectorX = enemyStartX + (battleSpriteSize / 2) - (ui.targetSelector.offsetWidth / 2); const selectorY = enemyStartY + selectedTargetIndex * enemySpacingY - ui.targetSelector.offsetHeight; ui.targetSelector.style.left = `${selectorX}px`; ui.targetSelector.style.top = `${selectorY}px`; ui.targetSelector.style.display = 'block'; } } else { ui.targetSelector.style.display = 'none'; } } }
            function handleBattleLogic() { if (battleState === 'processing' || currentAnimation) return; const currentUnit = turnOrder[currentTurnIndex]; if (currentUnit && currentUnit.isPlayer) { if (battleState === 'playerTurn' || battleState === 'playerChoosingSpell') { menuManager.update(); updateInfoPanel(menuManager.getCurrentDescription()); } else if (battleState === 'playerTargeting') { handleTargeting(); canvas.classList.add('targeting'); } } else { canvas.classList.remove('targeting'); } }
            canvas.addEventListener('click', (event) => { if (battleState !== 'playerTargeting') return; const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height; const x = (event.clientX - rect.left) * scaleX; const y = (event.clientY - rect.top) * scaleY; const battleSpriteSize = TILE_SIZE * 4; const enemyStartX = canvas.width - 150 - battleSpriteSize; const enemyStartY = 100; const enemySpacingY = 80; enemyUnits.forEach((enemy, index) => { const ex = enemyStartX; const ey = enemyStartY + index * enemySpacingY; if (x > ex && x < ex + battleSpriteSize && y > ey && y < ey + battleSpriteSize) { selectedTargetIndex = index; updateStatsUI(); executePlayerAction(); } }); });
            function handleTargeting() { if (Date.now() - menuManager.lastInputTime < 150) return; let actionTaken = false; if (keys['ArrowUp']) { selectedTargetIndex = (selectedTargetIndex - 1 + enemyUnits.length) % enemyUnits.length; actionTaken = true; } else if (keys['ArrowDown']) { selectedTargetIndex = (selectedTargetIndex + 1) % enemyUnits.length; actionTaken = true; } else if (keys['Enter'] || keys[' ']) { executePlayerAction(); actionTaken = true; } else if (keys['Escape'] || keys['Backspace']) { battleState = 'playerTurn'; pendingPlayerAction = null; updateInfoPanel(''); actionTaken = true; } if(actionTaken) { menuManager.lastInputTime = Date.now(); updateStatsUI(); } }
            function executePlayerAction() { battleState = 'processing'; updateInfoPanel(''); ui.targetSelector.style.display = 'none'; canvas.classList.remove('targeting'); const target = enemyUnits[selectedTargetIndex]; if (!target) { advanceTurn(); return; } if (pendingPlayerAction.type === 'attack') { const msg = playerUnit.attack(target); showMessage(msg, () => { checkBattleEnd(); if (gameState === 'battle') advanceTurn(); }); } else if (pendingPlayerAction.type === 'spell') { menuManager.castSpell(pendingPlayerAction.spellId, target); } pendingPlayerAction = null; }
            function advanceTurn() { updateStatsUI(); turnOrder = turnOrder.filter(unit => unit.hp > 0); if (checkBattleEnd()) return; currentTurnIndex = (currentTurnIndex + 1) % turnOrder.length; const nextUnit = turnOrder[currentTurnIndex]; if (!nextUnit) { console.error("Không tìm thấy đơn vị tiếp theo!"); endBattle(); return; } if (nextUnit.isPlayer) { battleState = 'playerTurn'; menuManager.switchMenu('main'); updateInfoPanel(menuManager.getCurrentDescription()); } else { battleState = 'processing'; updateInfoPanel(`Lượt của ${nextUnit.name}...`); setTimeout(() => executeEnemyTurn(nextUnit), 1200); } }
            function executeEnemyTurn(enemy) { updateInfoPanel(`Lượt của ${enemy.name}...`); if (enemy.specialSkill && Math.random() < enemy.specialSkill.chance) { const skill = enemy.specialSkill; playerUnit.hp = Math.max(0, playerUnit.hp - skill.damage); const msg = `${enemy.name} dùng ${skill.name}! Anh Hùng nhận ${skill.damage} sát thương!`; playScreenFlash('orange', 2, () => { showMessage(msg, () => { checkBattleEnd(); if(gameState === 'battle') advanceTurn(); }); }); } else { const msg = enemy.attack(playerUnit); showMessage(msg, () => { checkBattleEnd(); if(gameState === 'battle') advanceTurn(); }); } }
            function checkBattleEnd() { const wasInBattle = enemyUnits.length > 0; const defeatedForTurn = turnOrder.filter(u => !u.isPlayer && u.hp <= 0); enemyUnits = enemyUnits.filter(e => e.hp > 0); updateStatsUI(); if (playerUnit.hp <= 0) { battleState = 'processing'; gameState = 'gameOver'; updateInfoPanel('BẠN ĐÃ THUA!'); ui.gameOverScreen.style.display = 'flex'; return true; } if (wasInBattle && enemyUnits.length === 0) { battleState = 'processing'; updateInfoPanel('CHIẾN THẮNG!'); const droppedItems = []; turnOrder.filter(u => !u.isPlayer).forEach(defeatedUnit => { const baseMonster = monsterManager.monsters.find(m => m.id === defeatedUnit.baseName); if (baseMonster && baseMonster.dropItem && baseMonster.dropItem.name && Math.random() < baseMonster.dropItem.dropRate) { inventoryManager.addItem(baseMonster.dropItem.name, 1); droppedItems.push(baseMonster.dropItem.name); } }); const handlePostBattle = () => { playerDataManager.stats.battlesWon++; playerDataManager.save(); const willLevelUp = playerDataManager.stats.battlesWon >= playerDataManager.stats.battlesToNextLevel; if (willLevelUp) { handleLevelUp(endBattle); } else { endBattle(); } }; showMessage(`Bạn đã chiến thắng!`, () => { if (droppedItems.length > 0) { showMessage(`Bạn nhận được: ${droppedItems.join(', ')}!`, handlePostBattle); } else { handlePostBattle(); } }); return true; } return false; }
            function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

            map.generate();
            menuManager.init();
            setupDPadListeners();

            // Load saved player config on startup
            const savedPlayerConfigOnLoad = localStorage.getItem('custom_sprite_player_config');
            if (savedPlayerConfigOnLoad) {
                Object.assign(playerSpriteConfig, JSON.parse(savedPlayerConfigOnLoad));
            } else { // If no saved config, use the default player sprite config from imageManager
                const defaultPlayerSprite = imageManager.getImageById(spriteManager.defaultPlayerDataId);
                if (defaultPlayerSprite) {
                    Object.assign(playerSpriteConfig, {
                        isSpriteSheet: defaultPlayerSprite.isSpriteSheet,
                        frameWidth: defaultPlayerSprite.frameWidth,
                        frameHeight: defaultPlayerSprite.frameHeight,
                        framesPerRow: defaultPlayerSprite.framesPerRow,
                        animationRow: defaultPlayerSprite.animationRow,
                        animationSpeed: defaultPlayerSprite.animationSpeed,
                        totalRows: defaultPlayerSprite.totalRows
                    });
                }
            }


            spriteManager.loadAll(() => {
                if (!gameStarted) {
                    gameStarted = true;
                    gameLoop();
                }
            });
        }
    });
    </script>
</body>
</html>
